/* eslint-disable import/no-extraneous-dependencies */
import * as fc from 'fast-check';
import { _pushDepsToParent, _removeDupesWithParent, hoistDependencies, renderTree } from '../lib/hoisting';
import { _validateTree } from '../lib/index';
import { iterDeps, type PackageLockFile, type PackageLockPackage, type PackageLockTree } from '../lib/types';

if (process.env.FAST_CHECK_NUM_RUNS) {
  fc.configureGlobal({
    ...fc.readConfigureGlobal(),
    numRuns: Number(process.env.FAST_CHECK_NUM_RUNS),
  });
}

//////////////////////////////////////////////////////////////////////
//  Tests

test('every tree that is generated by the arbitrary is valid', () => {
  fc.assert(
    fc.property(arbPackageLock(), (tree) => {
      // eslint-disable-next-line no-console
      // console.log(JSON.stringify(tree, undefined, 2));
      _validateTree(tree);
    }),
  );
});

test('pushing dependencies to parent leaves a valid tree', () => {
  fc.assert(
    fc.property(arbPackageLock(), Logs.arb(), (tree, ctx) => {
      ctx.log(`Original tree:\n${renderTree(tree).map(x => `  ${x}`).join('\n')}`);
      const updated = _pushDepsToParent(tree);
      ctx.log(`Hoisted tree:\n${renderTree(updated).map(x => `  ${x}`).join('\n')}`);
      _validateTree(updated);
    }),
  );
});

test('removing dupes leaves a valid tree', () => {
  fc.assert(
    fc.property(arbPackageLock(), Logs.arb(), (tree, ctx) => {
      ctx.log('hoi');
      try {
        const updated = _removeDupesWithParent(tree);
        ctx.log('doei');
        _validateTree(updated);
      } catch (e) {
        ctx.log(`error ${e}`);
        throw e;
      }
    }),
  );
});

test('hoisting leaves a valid tree', () => {
  fc.assert(
    fc.property(arbPackageLock(), Logs.arb(), (tree, ctx) => {
      const updated = hoistDependencies(tree);
      ctx.log(`After hoisting: ${JSON.stringify(updated, undefined, 2)}`);
      _validateTree(updated);
    }),
  );
});

//////////////////////////////////////////////////////////////////////
//  Arbitraries

// This is for a nicer print behavior if the test fails
// We have to Object.create() with this otherwise `structuredClone` fails
const printsNicely = {
  toString() {
    return JSON.stringify(this, undefined, 2);
  },
};

function arbPackageLock(): fc.Arbitrary<PackageLockFile> {
  return arbPackageTree()
    .map((tree) => (Object.assign(Object.create(printsNicely), {
      version: '0.0.0',
      lockfileVersion: 1,
      name: 'root',
      requires: true,
      dependencies: tree.dependencies,
    } satisfies PackageLockFile)))
    .filter(isTreeConsistent);
}

function arbPackageTree(): fc.Arbitrary<PackageLockPackage> {
  const { tree } = fc.letrec((rec) => ({
    tree: fc.oneof(
      { depthSize: 'small', withCrossShrink: true },
      rec('leaf'),
      rec('node'),
    ) as ReturnType<typeof arbPackageTree>,
    leaf: arbLeafPackage(),
    node: fc.array(rec('tree') as ReturnType<typeof arbPackageTree>, { minLength: 0 }).chain(dependencies => {
      return fc.record({
        names: fc.array(arbPackageName(), { minLength: dependencies.length, maxLength: dependencies.length }),
        ranges: fc.tuple(...dependencies.map(d => arbRangeForVersion(d.version))),
        version: arbVersion(),
      }).map(({ names, ranges, version }) => {
        return {
          version,
          dependencies: Object.fromEntries(zip(names, dependencies)),
          requires: Object.fromEntries(zip(names, ranges)),
        } satisfies PackageLockPackage;
      });
    }),
  }));
  return tree;
}

function arbLeafPackage(): fc.Arbitrary<PackageLockPackage> {
  return fc.record({
    version: arbVersion(),
  });
}

function arbRangeOperator(): fc.Arbitrary<'' | '^' | '~'> {
  return fc.oneof(
    fc.constant(''),
    fc.constant('^'),
    fc.constant('~'),
  );
}

function arbPackageName(): fc.Arbitrary<string> {
  return fc.oneof(
    fc.constant('leftpad'),
    fc.constant('string-width'),
    fc.constant('is-even'),
    fc.constant('lodash'),
  );
}

interface Version {
  major: number;
  minor: number;
  patch: number;
}

function versionToString(x: Version) {
  return `${x.major}.${x.minor}.${x.patch}`;
}

function arbVersion(): fc.Arbitrary<string> {
  return fc.record({
    major: fc.integer({ min: 1, max: 10 }),
    minor: fc.nat({ max: 10 }),
    patch: fc.nat({ max: 10 }),
  }).map(versionToString);
}

function arbRangeForVersion(version: string): fc.Arbitrary<string> {
  const parts = version.split('.').map(Number);
  return fc.record({
    op: arbRangeOperator(),
    dec: fc.nat({ max: 5 }),
  }).map(({ op, dec }) => {
    switch (op) {
      case '':
        break;
      case '^':
        parts[1] = Math.max(0, parts[1] - dec);
        break;
      case '~':
        parts[2] = Math.max(0, parts[2] - dec);
        break;
    }
    return `${op}${parts.join('.')}`;
  });
}

function zip<A, B>(xs: A[], ys: B[]): [A, B][] {
  const ret: [A, B][] = [];
  for (let i = 0; i < Math.min(xs.length, ys.length); i++) {
    ret.push([xs[i], ys[i]]);
  }
  return ret;
}

class Logs {
  public static arb() {
    return fc.constant(new Logs());
  }

  private readonly lines = new Array<string>();

  public log(x: string) {
    this.lines.push(x);
  }

  public toString() {
    return this.lines.join('\n');
  }

  [fc.cloneMethod]() {
    return new Logs();
  }
}

/**
 * Make sure that trees don't have conflicting definitions for the same package version
 */
function isTreeConsistent(lock: PackageLockFile): boolean {
  return treeConsistencyError(lock) === undefined;
}

function treeConsistencyError(lock: PackageLockFile) {
  let error: string | undefined;
  const seen = new Map<string, string>();
  recurse(lock.name, lock);
  return error;

  function recurse(name: string, x: PackageLockTree) {
    if (error) {
      return;
    }

    const str = JSON.stringify(x);
    const key = `${name}@${x.version}`;
    const existing = seen.get(key);
    if (existing) {
      if (existing !== str) {
        error = `Inconsistent tree: ${key} has multiple definitions:\n${existing}\n${str}`;
        return;
      }
    } else {
      seen.set(key, str);
    }

    for (const [n, dep] of iterDeps(x)) {
      recurse(n, dep);
    }
  }
}
