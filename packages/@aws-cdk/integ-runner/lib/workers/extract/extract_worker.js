"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.integTestWorker = integTestWorker;
exports.watchTestWorker = watchTestWorker;
exports.snapshotTestWorker = snapshotTestWorker;
const workerpool = require("workerpool");
const runner_1 = require("../../runner");
const integration_tests_1 = require("../../runner/integration-tests");
const common_1 = require("../common");
/**
 * Runs a single integration test batch request.
 * If the test does not have an existing snapshot,
 * this will first generate a snapshot and then execute
 * the integration tests.
 *
 * If the tests succeed it will then save the snapshot
 */
function integTestWorker(request) {
    const failures = [];
    const verbosity = request.verbosity ?? 0;
    for (const testInfo of request.tests) {
        const test = new integration_tests_1.IntegTest({
            ...testInfo,
            watch: request.watch,
        }); // Hydrate from data
        const start = Date.now();
        try {
            const runner = new runner_1.IntegTestRunner({
                test,
                profile: request.profile,
                env: {
                    AWS_REGION: request.region,
                    CDK_DOCKER: process.env.CDK_DOCKER ?? 'docker',
                },
                showOutput: verbosity >= 2,
            }, testInfo.destructiveChanges);
            const tests = runner.actualTests();
            if (!tests || Object.keys(tests).length === 0) {
                throw new Error(`No tests defined for ${runner.testName}`);
            }
            for (const testCaseName of Object.keys(tests)) {
                try {
                    const results = runner.runIntegTestCase({
                        testCaseName,
                        clean: request.clean,
                        dryRun: request.dryRun,
                        updateWorkflow: request.updateWorkflow,
                        verbosity,
                    });
                    if (results && Object.values(results).some(result => result.status === 'fail')) {
                        failures.push(testInfo);
                        workerpool.workerEmit({
                            reason: common_1.DiagnosticReason.ASSERTION_FAILED,
                            testName: `${runner.testName}-${testCaseName} (${request.profile}/${request.region})`,
                            message: (0, common_1.formatAssertionResults)(results),
                            duration: (Date.now() - start) / 1000,
                        });
                    }
                    else {
                        workerpool.workerEmit({
                            reason: common_1.DiagnosticReason.TEST_SUCCESS,
                            testName: `${runner.testName}-${testCaseName}`,
                            message: results ? (0, common_1.formatAssertionResults)(results) : 'NO ASSERTIONS',
                            duration: (Date.now() - start) / 1000,
                        });
                    }
                }
                catch (e) {
                    failures.push(testInfo);
                    workerpool.workerEmit({
                        reason: common_1.DiagnosticReason.TEST_FAILED,
                        testName: `${runner.testName}-${testCaseName} (${request.profile}/${request.region})`,
                        message: `Integration test failed: ${e}`,
                        duration: (Date.now() - start) / 1000,
                    });
                }
            }
        }
        catch (e) {
            failures.push(testInfo);
            workerpool.workerEmit({
                reason: common_1.DiagnosticReason.TEST_ERROR,
                testName: `${testInfo.fileName} (${request.profile}/${request.region})`,
                message: `Error during integration test: ${e}`,
                duration: (Date.now() - start) / 1000,
            });
        }
    }
    return failures;
}
async function watchTestWorker(options) {
    const verbosity = options.verbosity ?? 0;
    const test = new integration_tests_1.IntegTest(options);
    const runner = new runner_1.IntegTestRunner({
        test,
        profile: options.profile,
        env: {
            AWS_REGION: options.region,
            CDK_DOCKER: process.env.CDK_DOCKER ?? 'docker',
        },
        showOutput: verbosity >= 2,
    });
    runner.createCdkContextJson();
    const tests = runner.actualTests();
    if (!tests || Object.keys(tests).length === 0) {
        throw new Error(`No tests defined for ${runner.testName}`);
    }
    for (const testCaseName of Object.keys(tests)) {
        await runner.watchIntegTest({
            testCaseName,
            verbosity,
        });
    }
}
/**
 * Runs a single snapshot test batch request.
 * For each integration test this will check to see
 * if there is an existing snapshot, and if there is will
 * check if there are any changes
 */
function snapshotTestWorker(testInfo, options = {}) {
    const failedTests = new Array();
    const start = Date.now();
    const test = new integration_tests_1.IntegTest(testInfo); // Hydrate the data record again
    const timer = setTimeout(() => {
        workerpool.workerEmit({
            reason: common_1.DiagnosticReason.SNAPSHOT_ERROR,
            testName: test.testName,
            message: 'Test is taking a very long time',
            duration: (Date.now() - start) / 1000,
        });
    }, 60000);
    try {
        const runner = new runner_1.IntegSnapshotRunner({ test });
        if (!runner.hasSnapshot()) {
            workerpool.workerEmit({
                reason: common_1.DiagnosticReason.NO_SNAPSHOT,
                testName: test.testName,
                message: 'No Snapshot',
                duration: (Date.now() - start) / 1000,
            });
            failedTests.push(test.info);
        }
        else {
            const { diagnostics, destructiveChanges } = runner.testSnapshot(options);
            if (diagnostics.length > 0) {
                diagnostics.forEach(diagnostic => workerpool.workerEmit({
                    ...diagnostic,
                    duration: (Date.now() - start) / 1000,
                }));
                failedTests.push({
                    ...test.info,
                    destructiveChanges,
                });
            }
            else {
                workerpool.workerEmit({
                    reason: common_1.DiagnosticReason.SNAPSHOT_SUCCESS,
                    testName: test.testName,
                    message: 'Success',
                    duration: (Date.now() - start) / 1000,
                });
            }
        }
    }
    catch (e) {
        failedTests.push(test.info);
        workerpool.workerEmit({
            message: e.message,
            testName: test.testName,
            reason: common_1.DiagnosticReason.SNAPSHOT_ERROR,
            duration: (Date.now() - start) / 1000,
        });
    }
    finally {
        clearTimeout(timer);
    }
    return failedTests;
}
workerpool.worker({
    snapshotTestWorker,
    integTestWorker,
    watchTestWorker,
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXh0cmFjdF93b3JrZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJleHRyYWN0X3dvcmtlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQWlCQSwwQ0EwRUM7QUFFRCwwQ0F3QkM7QUFRRCxnREF5REM7QUF0TEQseUNBQXlDO0FBQ3pDLHlDQUFvRTtBQUVwRSxzRUFBMkQ7QUFFM0Qsc0NBQXFFO0FBSXJFOzs7Ozs7O0dBT0c7QUFDSCxTQUFnQixlQUFlLENBQUMsT0FBOEI7SUFDNUQsTUFBTSxRQUFRLEdBQW9CLEVBQUUsQ0FBQztJQUNyQyxNQUFNLFNBQVMsR0FBRyxPQUFPLENBQUMsU0FBUyxJQUFJLENBQUMsQ0FBQztJQUV6QyxLQUFLLE1BQU0sUUFBUSxJQUFJLE9BQU8sQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUNyQyxNQUFNLElBQUksR0FBRyxJQUFJLDZCQUFTLENBQUM7WUFDekIsR0FBRyxRQUFRO1lBQ1gsS0FBSyxFQUFFLE9BQU8sQ0FBQyxLQUFLO1NBQ3JCLENBQUMsQ0FBQyxDQUFDLG9CQUFvQjtRQUN4QixNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7UUFFekIsSUFBSSxDQUFDO1lBQ0gsTUFBTSxNQUFNLEdBQUcsSUFBSSx3QkFBZSxDQUFDO2dCQUNqQyxJQUFJO2dCQUNKLE9BQU8sRUFBRSxPQUFPLENBQUMsT0FBTztnQkFDeEIsR0FBRyxFQUFFO29CQUNILFVBQVUsRUFBRSxPQUFPLENBQUMsTUFBTTtvQkFDMUIsVUFBVSxFQUFFLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxJQUFJLFFBQVE7aUJBQy9DO2dCQUNELFVBQVUsRUFBRSxTQUFTLElBQUksQ0FBQzthQUMzQixFQUFFLFFBQVEsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1lBRWhDLE1BQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUVuQyxJQUFJLENBQUMsS0FBSyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMs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QUFDO0FBQ3JCLENBQUM7QUFFRCxVQUFVLENBQUMsTUFBTSxDQUFDO0lBQ2hCLGtCQUFrQjtJQUNsQixlQUFlO0lBQ2YsZUFBZTtDQUNoQixDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB3b3JrZXJwb29sIGZyb20gJ3dvcmtlcnBvb2wnO1xuaW1wb3J0IHsgSW50ZWdTbmFwc2hvdFJ1bm5lciwgSW50ZWdUZXN0UnVubmVyIH0gZnJvbSAnLi4vLi4vcnVubmVyJztcbmltcG9ydCB0eXBlIHsgSW50ZWdUZXN0SW5mbyB9IGZyb20gJy4uLy4uL3J1bm5lci9pbnRlZ3JhdGlvbi10ZXN0cyc7XG5pbXBvcnQgeyBJbnRlZ1Rlc3QgfSBmcm9tICcuLi8uLi9ydW5uZXIvaW50ZWdyYXRpb24tdGVzdHMnO1xuaW1wb3J0IHR5cGUgeyBJbnRlZ1Rlc3RXb3JrZXJDb25maWcsIFNuYXBzaG90VmVyaWZpY2F0aW9uT3B0aW9ucywgRGlhZ25vc3RpYyB9IGZyb20gJy4uL2NvbW1vbic7XG5pbXBvcnQgeyBEaWFnbm9zdGljUmVhc29uLCBmb3JtYXRBc3NlcnRpb25SZXN1bHRzIH0gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCB0eXBlIHsgSW50ZWdUZXN0QmF0Y2hSZXF1ZXN0IH0gZnJvbSAnLi4vaW50ZWctdGVzdC13b3JrZXInO1xuaW1wb3J0IHR5cGUgeyBJbnRlZ1dhdGNoT3B0aW9ucyB9IGZyb20gJy4uL2ludGVnLXdhdGNoLXdvcmtlcic7XG5cbi8qKlxuICogUnVucyBhIHNpbmdsZSBpbnRlZ3JhdGlvbiB0ZXN0IGJhdGNoIHJlcXVlc3QuXG4gKiBJZiB0aGUgdGVzdCBkb2VzIG5vdCBoYXZlIGFuIGV4aXN0aW5nIHNuYXBzaG90LFxuICogdGhpcyB3aWxsIGZpcnN0IGdlbmVyYXRlIGEgc25hcHNob3QgYW5kIHRoZW4gZXhlY3V0ZVxuICogdGhlIGludGVncmF0aW9uIHRlc3RzLlxuICpcbiAqIElmIHRoZSB0ZXN0cyBzdWNjZWVkIGl0IHdpbGwgdGhlbiBzYXZlIHRoZSBzbmFwc2hvdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZWdUZXN0V29ya2VyKHJlcXVlc3Q6IEludGVnVGVzdEJhdGNoUmVxdWVzdCk6IEludGVnVGVzdFdvcmtlckNvbmZpZ1tdIHtcbiAgY29uc3QgZmFpbHVyZXM6IEludGVnVGVzdEluZm9bXSA9IFtdO1xuICBjb25zdCB2ZXJib3NpdHkgPSByZXF1ZXN0LnZlcmJvc2l0eSA/PyAwO1xuXG4gIGZvciAoY29uc3QgdGVzdEluZm8gb2YgcmVxdWVzdC50ZXN0cykge1xuICAgIGNvbnN0IHRlc3QgPSBuZXcgSW50ZWdUZXN0KHtcbiAgICAgIC4uLnRlc3RJbmZvLFxuICAgICAgd2F0Y2g6IHJlcXVlc3Qud2F0Y2gsXG4gICAgfSk7IC8vIEh5ZHJhdGUgZnJvbSBkYXRhXG4gICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJ1bm5lciA9IG5ldyBJbnRlZ1Rlc3RSdW5uZXIoe1xuICAgICAgICB0ZXN0LFxuICAgICAgICBwcm9maWxlOiByZXF1ZXN0LnByb2ZpbGUsXG4gICAgICAgIGVudjoge1xuICAgICAgICAgIEFXU19SRUdJT046IHJlcXVlc3QucmVnaW9uLFxuICAgICAgICAgIENES19ET0NLRVI6IHByb2Nlc3MuZW52LkNES19ET0NLRVIgPz8gJ2RvY2tlcicsXG4gICAgICAgIH0sXG4gICAgICAgIHNob3dPdXRwdXQ6IHZlcmJvc2l0eSA+PSAyLFxuICAgICAgfSwgdGVzdEluZm8uZGVzdHJ1Y3RpdmVDaGFuZ2VzKTtcblxuICAgICAgY29uc3QgdGVzdHMgPSBydW5uZXIuYWN0dWFsVGVzdHMoKTtcblxuICAgICAgaWYgKCF0ZXN0cyB8fCBPYmplY3Qua2V5cyh0ZXN0cykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gdGVzdHMgZGVmaW5lZCBmb3IgJHtydW5uZXIudGVzdE5hbWV9YCk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHRlc3RDYXNlTmFtZSBvZiBPYmplY3Qua2V5cyh0ZXN0cykpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXN1bHRzID0gcnVubmVyLnJ1bkludGVnVGVzdENhc2Uoe1xuICAgICAgICAgICAgdGVzdENhc2VOYW1lLFxuICAgICAgICAgICAgY2xlYW46IHJlcXVlc3QuY2xlYW4sXG4gICAgICAgICAgICBkcnlSdW46IHJlcXVlc3QuZHJ5UnVuLFxuICAgICAgICAgICAgdXBkYXRlV29ya2Zsb3c6IHJlcXVlc3QudXBkYXRlV29ya2Zsb3csXG4gICAgICAgICAgICB2ZXJib3NpdHksXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHJlc3VsdHMgJiYgT2JqZWN0LnZhbHVlcyhyZXN1bHRzKS5zb21lKHJlc3VsdCA9PiByZXN1bHQuc3RhdHVzID09PSAnZmFpbCcpKSB7XG4gICAgICAgICAgICBmYWlsdXJlcy5wdXNoKHRlc3RJbmZvKTtcbiAgICAgICAgICAgIHdvcmtlcnBvb2wud29ya2VyRW1pdCh7XG4gICAgICAgICAgICAgIHJlYXNvbjogRGlhZ25vc3RpY1JlYXNvbi5BU1NFUlRJT05fRkFJTEVELFxuICAgICAgICAgICAgICB0ZXN0TmFtZTogYCR7cnVubmVyLnRlc3ROYW1lfS0ke3Rlc3RDYXNlTmFtZX0gKCR7cmVxdWVzdC5wcm9maWxlfS8ke3JlcXVlc3QucmVnaW9ufSlgLFxuICAgICAgICAgICAgICBtZXNzYWdlOiBmb3JtYXRBc3NlcnRpb25SZXN1bHRzKHJlc3VsdHMpLFxuICAgICAgICAgICAgICBkdXJhdGlvbjogKERhdGUubm93KCkgLSBzdGFydCkgLyAxMDAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdvcmtlcnBvb2wud29ya2VyRW1pdCh7XG4gICAgICAgICAgICAgIHJlYXNvbjogRGlhZ25vc3RpY1JlYXNvbi5URVNUX1NVQ0NFU1MsXG4gICAgICAgICAgICAgIHRlc3ROYW1lOiBgJHtydW5uZXIudGVzdE5hbWV9LSR7dGVzdENhc2VOYW1lfWAsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IHJlc3VsdHMgPyBmb3JtYXRBc3NlcnRpb25SZXN1bHRzKHJlc3VsdHMpIDogJ05PIEFTU0VSVElPTlMnLFxuICAgICAgICAgICAgICBkdXJhdGlvbjogKERhdGUubm93KCkgLSBzdGFydCkgLyAxMDAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZmFpbHVyZXMucHVzaCh0ZXN0SW5mbyk7XG4gICAgICAgICAgd29ya2VycG9vbC53b3JrZXJFbWl0KHtcbiAgICAgICAgICAgIHJlYXNvbjogRGlhZ25vc3RpY1JlYXNvbi5URVNUX0ZBSUxFRCxcbiAgICAgICAgICAgIHRlc3ROYW1lOiBgJHtydW5uZXIudGVzdE5hbWV9LSR7dGVzdENhc2VOYW1lfSAoJHtyZXF1ZXN0LnByb2ZpbGV9LyR7cmVxdWVzdC5yZWdpb259KWAsXG4gICAgICAgICAgICBtZXNzYWdlOiBgSW50ZWdyYXRpb24gdGVzdCBmYWlsZWQ6ICR7ZX1gLFxuICAgICAgICAgICAgZHVyYXRpb246IChEYXRlLm5vdygpIC0gc3RhcnQpIC8gMTAwMCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGZhaWx1cmVzLnB1c2godGVzdEluZm8pO1xuICAgICAgd29ya2VycG9vbC53b3JrZXJFbWl0KHtcbiAgICAgICAgcmVhc29uOiBEaWFnbm9zdGljUmVhc29uLlRFU1RfRVJST1IsXG4gICAgICAgIHRlc3ROYW1lOiBgJHt0ZXN0SW5mby5maWxlTmFtZX0gKCR7cmVxdWVzdC5wcm9maWxlfS8ke3JlcXVlc3QucmVnaW9ufSlgLFxuICAgICAgICBtZXNzYWdlOiBgRXJyb3IgZHVyaW5nIGludGVncmF0aW9uIHRlc3Q6ICR7ZX1gLFxuICAgICAgICBkdXJhdGlvbjogKERhdGUubm93KCkgLSBzdGFydCkgLyAxMDAwLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhaWx1cmVzO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd2F0Y2hUZXN0V29ya2VyKG9wdGlvbnM6IEludGVnV2F0Y2hPcHRpb25zKSB7XG4gIGNvbnN0IHZlcmJvc2l0eSA9IG9wdGlvbnMudmVyYm9zaXR5ID8/IDA7XG4gIGNvbnN0IHRlc3QgPSBuZXcgSW50ZWdUZXN0KG9wdGlvbnMpO1xuICBjb25zdCBydW5uZXIgPSBuZXcgSW50ZWdUZXN0UnVubmVyKHtcbiAgICB0ZXN0LFxuICAgIHByb2ZpbGU6IG9wdGlvbnMucHJvZmlsZSxcbiAgICBlbnY6IHtcbiAgICAgIEFXU19SRUdJT046IG9wdGlvbnMucmVnaW9uLFxuICAgICAgQ0RLX0RPQ0tFUjogcHJvY2Vzcy5lbnYuQ0RLX0RPQ0tFUiA/PyAnZG9ja2VyJyxcbiAgICB9LFxuICAgIHNob3dPdXRwdXQ6IHZlcmJvc2l0eSA+PSAyLFxuICB9KTtcbiAgcnVubmVyLmNyZWF0ZUNka0NvbnRleHRKc29uKCk7XG4gIGNvbnN0IHRlc3RzID0gcnVubmVyLmFjdHVhbFRlc3RzKCk7XG5cbiAgaWYgKCF0ZXN0cyB8fCBPYmplY3Qua2V5cyh0ZXN0cykubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBObyB0ZXN0cyBkZWZpbmVkIGZvciAke3J1bm5lci50ZXN0TmFtZX1gKTtcbiAgfVxuICBmb3IgKGNvbnN0IHRlc3RDYXNlTmFtZSBvZiBPYmplY3Qua2V5cyh0ZXN0cykpIHtcbiAgICBhd2FpdCBydW5uZXIud2F0Y2hJbnRlZ1Rlc3Qoe1xuICAgICAgdGVzdENhc2VOYW1lLFxuICAgICAgdmVyYm9zaXR5LFxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogUnVucyBhIHNpbmdsZSBzbmFwc2hvdCB0ZXN0IGJhdGNoIHJlcXVlc3QuXG4gKiBGb3IgZWFjaCBpbnRlZ3JhdGlvbiB0ZXN0IHRoaXMgd2lsbCBjaGVjayB0byBzZWVcbiAqIGlmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIHNuYXBzaG90LCBhbmQgaWYgdGhlcmUgaXMgd2lsbFxuICogY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBjaGFuZ2VzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbmFwc2hvdFRlc3RXb3JrZXIodGVzdEluZm86IEludGVnVGVzdEluZm8sIG9wdGlvbnM6IFNuYXBzaG90VmVyaWZpY2F0aW9uT3B0aW9ucyA9IHt9KTogSW50ZWdUZXN0V29ya2VyQ29uZmlnW10ge1xuICBjb25zdCBmYWlsZWRUZXN0cyA9IG5ldyBBcnJheTxJbnRlZ1Rlc3RXb3JrZXJDb25maWc+KCk7XG4gIGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgY29uc3QgdGVzdCA9IG5ldyBJbnRlZ1Rlc3QodGVzdEluZm8pOyAvLyBIeWRyYXRlIHRoZSBkYXRhIHJlY29yZCBhZ2FpblxuXG4gIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgd29ya2VycG9vbC53b3JrZXJFbWl0KHtcbiAgICAgIHJlYXNvbjogRGlhZ25vc3RpY1JlYXNvbi5TTkFQU0hPVF9FUlJPUixcbiAgICAgIHRlc3ROYW1lOiB0ZXN0LnRlc3ROYW1lLFxuICAgICAgbWVzc2FnZTogJ1Rlc3QgaXMgdGFraW5nIGEgdmVyeSBsb25nIHRpbWUnLFxuICAgICAgZHVyYXRpb246IChEYXRlLm5vdygpIC0gc3RhcnQpIC8gMTAwMCxcbiAgICB9KTtcbiAgfSwgNjBfMDAwKTtcblxuICB0cnkge1xuICAgIGNvbnN0IHJ1bm5lciA9IG5ldyBJbnRlZ1NuYXBzaG90UnVubmVyKHsgdGVzdCB9KTtcbiAgICBpZiAoIXJ1bm5lci5oYXNTbmFwc2hvdCgpKSB7XG4gICAgICB3b3JrZXJwb29sLndvcmtlckVtaXQoe1xuICAgICAgICByZWFzb246IERpYWdub3N0aWNSZWFzb24uTk9fU05BUFNIT1QsXG4gICAgICAgIHRlc3ROYW1lOiB0ZXN0LnRlc3ROYW1lLFxuICAgICAgICBtZXNzYWdlOiAnTm8gU25hcHNob3QnLFxuICAgICAgICBkdXJhdGlvbjogKERhdGUubm93KCkgLSBzdGFydCkgLyAxMDAwLFxuICAgICAgfSk7XG4gICAgICBmYWlsZWRUZXN0cy5wdXNoKHRlc3QuaW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHsgZGlhZ25vc3RpY3MsIGRlc3RydWN0aXZlQ2hhbmdlcyB9ID0gcnVubmVyLnRlc3RTbmFwc2hvdChvcHRpb25zKTtcbiAgICAgIGlmIChkaWFnbm9zdGljcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGRpYWdub3N0aWNzLmZvckVhY2goZGlhZ25vc3RpYyA9PiB3b3JrZXJwb29sLndvcmtlckVtaXQoe1xuICAgICAgICAgIC4uLmRpYWdub3N0aWMsXG4gICAgICAgICAgZHVyYXRpb246IChEYXRlLm5vdygpIC0gc3RhcnQpIC8gMTAwMCxcbiAgICAgICAgfSBhcyBEaWFnbm9zdGljKSk7XG4gICAgICAgIGZhaWxlZFRlc3RzLnB1c2goe1xuICAgICAgICAgIC4uLnRlc3QuaW5mbyxcbiAgICAgICAgICBkZXN0cnVjdGl2ZUNoYW5nZXMsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd29ya2VycG9vbC53b3JrZXJFbWl0KHtcbiAgICAgICAgICByZWFzb246IERpYWdub3N0aWNSZWFzb24uU05BUFNIT1RfU1VDQ0VTUyxcbiAgICAgICAgICB0ZXN0TmFtZTogdGVzdC50ZXN0TmFtZSxcbiAgICAgICAgICBtZXNzYWdlOiAnU3VjY2VzcycsXG4gICAgICAgICAgZHVyYXRpb246IChEYXRlLm5vdygpIC0gc3RhcnQpIC8gMTAwMCxcbiAgICAgICAgfSBhcyBEaWFnbm9zdGljKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgIGZhaWxlZFRlc3RzLnB1c2godGVzdC5pbmZvKTtcbiAgICB3b3JrZXJwb29sLndvcmtlckVtaXQoe1xuICAgICAgbWVzc2FnZTogZS5tZXNzYWdlLFxuICAgICAgdGVzdE5hbWU6IHRlc3QudGVzdE5hbWUsXG4gICAgICByZWFzb246IERpYWdub3N0aWNSZWFzb24uU05BUFNIT1RfRVJST1IsXG4gICAgICBkdXJhdGlvbjogKERhdGUubm93KCkgLSBzdGFydCkgLyAxMDAwLFxuICAgIH0gYXMgRGlhZ25vc3RpYyk7XG4gIH0gZmluYWxseSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgfVxuXG4gIHJldHVybiBmYWlsZWRUZXN0cztcbn1cblxud29ya2VycG9vbC53b3JrZXIoe1xuICBzbmFwc2hvdFRlc3RXb3JrZXIsXG4gIGludGVnVGVzdFdvcmtlcixcbiAgd2F0Y2hUZXN0V29ya2VyLFxufSk7XG4iXX0=