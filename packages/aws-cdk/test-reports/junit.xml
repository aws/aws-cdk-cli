<?xml version="1.0" encoding="UTF-8"?>
<testsuites name="jest tests" tests="1109" failures="0" errors="0" time="55.928">
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:40:45" time="0.604" tests="1">
    <testcase classname=" returns credential from plugin" name=" returns credential from plugin" time="0.007">
    </testcase>
  </testsuite>
  <testsuite name="validateversion without bootstrap stack" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:40:45" time="2.535" tests="6">
    <testcase classname="validateversion without bootstrap stack validating version with access denied error gives upgrade hint" name="validateversion without bootstrap stack validating version with access denied error gives upgrade hint" time="0.024">
    </testcase>
    <testcase classname="validateversion without bootstrap stack validating version without explicit SSM parameter fails" name="validateversion without bootstrap stack validating version without explicit SSM parameter fails" time="0.003">
    </testcase>
    <testcase classname="validateversion without bootstrap stack validating version with missing parameter gives bootstrap hint" name="validateversion without bootstrap stack validating version with missing parameter gives bootstrap hint" time="0.002">
    </testcase>
    <testcase classname="validateversion without bootstrap stack validating version with explicit SSM parameter succeeds" name="validateversion without bootstrap stack validating version with explicit SSM parameter succeeds" time="0.003">
    </testcase>
    <testcase classname=" failure to read SSM parameter results in upgrade message for existing bootstrap stack under v5" name=" failure to read SSM parameter results in upgrade message for existing bootstrap stack under v5" time="0.002">
    </testcase>
    <testcase classname=" failure to read SSM parameter results in exception passthrough for existing bootstrap stack v5 or higher" name=" failure to read SSM parameter results in exception passthrough for existing bootstrap stack v5 or higher" time="0.005">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:40:45" time="2.832" tests="13">
    <testcase classname=" even if the bootstrap stack failed to create, can still retry bootstrapping it" name=" even if the bootstrap stack failed to create, can still retry bootstrapping it" time="0.044">
    </testcase>
    <testcase classname=" do bootstrap" name=" do bootstrap" time="0.037">
    </testcase>
    <testcase classname=" do bootstrap using custom bucket name" name=" do bootstrap using custom bucket name" time="0.028">
    </testcase>
    <testcase classname=" passing trusted accounts to the old bootstrapping results in an error" name=" passing trusted accounts to the old bootstrapping results in an error" time="0.026">
    </testcase>
    <testcase classname=" even if the bootstrap stack is in a rollback state, can still retry bootstrapping it" name=" even if the bootstrap stack is in a rollback state, can still retry bootstrapping it" time="0.015">
    </testcase>
    <testcase classname=" stack is termination protected when set" name=" stack is termination protected when set" time="0.016">
    </testcase>
    <testcase classname=" do showTemplate JSON" name=" do showTemplate JSON" time="0.007">
    </testcase>
    <testcase classname=" do bootstrap with custom tags for toolkit stack" name=" do bootstrap with custom tags for toolkit stack" time="0.017">
    </testcase>
    <testcase classname=" bootstrap disable bucket Public Access Block Configuration" name=" bootstrap disable bucket Public Access Block Configuration" time="0.039">
    </testcase>
    <testcase classname=" do bootstrap using KMS CMK" name=" do bootstrap using KMS CMK" time="0.016">
    </testcase>
    <testcase classname=" passing CFN execution policies to the old bootstrapping results in an error" name=" passing CFN execution policies to the old bootstrapping results in an error" time="0.007">
    </testcase>
    <testcase classname=" do showTemplate YAML" name=" do showTemplate YAML" time="0.008">
    </testcase>
    <testcase classname=" stack is not termination protected by default" name=" stack is not termination protected by default" time="0.02">
    </testcase>
  </testsuite>
  <testsuite name="Bootstrapping v2" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:40:45" time="3.638" tests="31">
    <testcase classname="Bootstrapping v2 passing no CFN managed policies without trusted accounts is okay" name="Bootstrapping v2 passing no CFN managed policies without trusted accounts is okay" time="0.145">
    </testcase>
    <testcase classname="Bootstrapping v2 passing trusted accounts without CFN managed policies results in an error" name="Bootstrapping v2 passing trusted accounts without CFN managed policies results in an error" time="0.037">
    </testcase>
    <testcase classname="Bootstrapping v2 passes value to PermissionsBoundary" name="Bootstrapping v2 passes value to PermissionsBoundary" time="0.027">
    </testcase>
    <testcase classname="Bootstrapping v2 adding permission boundary with path in policy name" name="Bootstrapping v2 adding permission boundary with path in policy name" time="0.022">
    </testcase>
    <testcase classname="Bootstrapping v2 allow adding trusted account if there was already a policy on the stack" name="Bootstrapping v2 allow adding trusted account if there was already a policy on the stack" time="0.018">
    </testcase>
    <testcase classname="Bootstrapping v2 do not allow accounts to be listed as both trusted and untrusted" name="Bootstrapping v2 do not allow accounts to be listed as both trusted and untrusted" time="0.017">
    </testcase>
    <testcase classname="Bootstrapping v2 passing trusted accounts for lookup generates the correct stack parameter" name="Bootstrapping v2 passing trusted accounts for lookup generates the correct stack parameter" time="0.02">
    </testcase>
    <testcase classname="Bootstrapping v2 passes the KMS key ID as a CFN parameter" name="Bootstrapping v2 passes the KMS key ID as a CFN parameter" time="0.039">
    </testcase>
    <testcase classname="Bootstrapping v2 KMS key (upgrading) current param &quot;arn:aws:key&quot;, createCustomerMasterKey=undefined =&gt; parameter becomes undefined " name="Bootstrapping v2 KMS key (upgrading) current param &quot;arn:aws:key&quot;, createCustomerMasterKey=undefined =&gt; parameter becomes undefined " time="0.11">
    </testcase>
    <testcase classname="Bootstrapping v2 KMS key (new stack) createCustomerMasterKey=true =&gt; parameter becomes &quot;&quot; " name="Bootstrapping v2 KMS key (new stack) createCustomerMasterKey=true =&gt; parameter becomes &quot;&quot; " time="0.023">
    </testcase>
    <testcase classname="Bootstrapping v2 KMS key (new stack) createCustomerMasterKey=false =&gt; parameter becomes &quot;AWS_MANAGED_KEY&quot; " name="Bootstrapping v2 KMS key (new stack) createCustomerMasterKey=false =&gt; parameter becomes &quot;AWS_MANAGED_KEY&quot; " time="0.021">
    </testcase>
    <testcase classname="Bootstrapping v2 KMS key (new stack) createCustomerMasterKey=undefined =&gt; parameter becomes &quot;AWS_MANAGED_KEY&quot; " name="Bootstrapping v2 KMS key (new stack) createCustomerMasterKey=undefined =&gt; parameter becomes &quot;AWS_MANAGED_KEY&quot; " time="0.02">
    </testcase>
    <testcase classname="Bootstrapping v2 KMS key (upgrading) current param undefined, createCustomerMasterKey=undefined =&gt; parameter becomes &quot;AWS_MANAGED_KEY&quot; " name="Bootstrapping v2 KMS key (upgrading) current param undefined, createCustomerMasterKey=undefined =&gt; parameter becomes &quot;AWS_MANAGED_KEY&quot; " time="0.028">
    </testcase>
    <testcase classname="Bootstrapping v2 KMS key (upgrading) current param &quot;AWS_MANAGED_KEY&quot;, createCustomerMasterKey=true =&gt; parameter becomes &quot;&quot; " name="Bootstrapping v2 KMS key (upgrading) current param &quot;AWS_MANAGED_KEY&quot;, createCustomerMasterKey=true =&gt; parameter becomes &quot;&quot; " time="0.025">
    </testcase>
    <testcase classname="Bootstrapping v2 KMS key (upgrading) current param &quot;arn:aws:key&quot;, createCustomerMasterKey=false =&gt; parameter becomes &quot;AWS_MANAGED_KEY&quot; " name="Bootstrapping v2 KMS key (upgrading) current param &quot;arn:aws:key&quot;, createCustomerMasterKey=false =&gt; parameter becomes &quot;AWS_MANAGED_KEY&quot; " time="0.028">
    </testcase>
    <testcase classname="Bootstrapping v2 passes the bucket name as a CFN parameter" name="Bootstrapping v2 passes the bucket name as a CFN parameter" time="0.023">
    </testcase>
    <testcase classname="Bootstrapping v2 termination protection stack is not termination protected by default" name="Bootstrapping v2 termination protection stack is not termination protected by default" time="0.022">
    </testcase>
    <testcase classname="Bootstrapping v2 termination protection termination protection is left alone when option is not given" name="Bootstrapping v2 termination protection termination protection is left alone when option is not given" time="0.023">
    </testcase>
    <testcase classname="Bootstrapping v2 termination protection stack is termination protected when option is set" name="Bootstrapping v2 termination protection stack is termination protected when option is set" time="0.02">
    </testcase>
    <testcase classname="Bootstrapping v2 termination protection termination protection can be switched off" name="Bootstrapping v2 termination protection termination protection can be switched off" time="0.018">
    </testcase>
    <testcase classname="Bootstrapping v2 adding new permissions boundary" name="Bootstrapping v2 adding new permissions boundary" time="0.021">
    </testcase>
    <testcase classname="Bootstrapping v2 passing trusted accounts without CFN managed policies on the existing stack results in an error" name="Bootstrapping v2 passing trusted accounts without CFN managed policies on the existing stack results in an error" time="0.014">
    </testcase>
    <testcase classname="Bootstrapping v2 removes trusted account when it is listed as untrusted" name="Bootstrapping v2 removes trusted account when it is listed as untrusted" time="0.025">
    </testcase>
    <testcase classname="Bootstrapping v2 Do not allow downgrading bootstrap stack version" name="Bootstrapping v2 Do not allow downgrading bootstrap stack version" time="0.012">
    </testcase>
    <testcase classname="Bootstrapping v2 removing existing permissions boundary" name="Bootstrapping v2 removing existing permissions boundary" time="0.021">
    </testcase>
    <testcase classname="Bootstrapping v2 permission boundary switch message does not appear" name="Bootstrapping v2 permission boundary switch message does not appear" time="0.037">
    </testcase>
    <testcase classname="Bootstrapping v2 removes trusted account for lookup when it is listed as untrusted" name="Bootstrapping v2 removes trusted account for lookup when it is listed as untrusted" time="0.015">
    </testcase>
    <testcase classname="Bootstrapping v2 passes false to PublicAccessBlockConfiguration" name="Bootstrapping v2 passes false to PublicAccessBlockConfiguration" time="0.016">
    </testcase>
    <testcase classname="Bootstrapping v2 Do not allow overwriting bootstrap stack from a different vendor" name="Bootstrapping v2 Do not allow overwriting bootstrap stack from a different vendor" time="0.012">
    </testcase>
    <testcase classname="Bootstrapping v2 bootstrap template has the right exports" name="Bootstrapping v2 bootstrap template has the right exports" time="0.018">
    </testcase>
    <testcase classname="Bootstrapping v2 passes true to PermissionsBoundary" name="Bootstrapping v2 passes true to PermissionsBoundary" time="0.024">
    </testcase>
  </testsuite>
  <testsuite name="with intercepted network calls" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:40:45" time="3.996" tests="31">
    <testcase classname="with intercepted network calls defaultAccount returns undefined, event if STS call fails with ExpiredToken" name="with intercepted network calls defaultAccount returns undefined, event if STS call fails with ExpiredToken" time="0.085">
    </testcase>
    <testcase classname="with intercepted network calls support for credential_source assume fails with unsupported credential_source" name="with intercepted network calls support for credential_source assume fails with unsupported credential_source" time="0.133">
    </testcase>
    <testcase classname="with intercepted network calls support for credential_source can assume role with ecs credentials" name="with intercepted network calls support for credential_source can assume role with ecs credentials" time="0.01">
    </testcase>
    <testcase classname="with intercepted network calls support for credential_source can assume role with env credentials" name="with intercepted network calls support for credential_source can assume role with env credentials" time="0.009">
    </testcase>
    <testcase classname="with intercepted network calls support for credential_source can assume role with ec2 credentials" name="with intercepted network calls support for credential_source can assume role with ec2 credentials" time="0.011">
    </testcase>
    <testcase classname="with intercepted network calls Plugins can assume role with credentials from plugin" name="with intercepted network calls Plugins can assume role with credentials from plugin" time="0.103">
    </testcase>
    <testcase classname="with intercepted network calls Plugins even if AssumeRole fails but current credentials are from a plugin, we will still use them" name="with intercepted network calls Plugins even if AssumeRole fails but current credentials are from a plugin, we will still use them" time="0.034">
    </testcase>
    <testcase classname="with intercepted network calls Plugins uses plugin for account 99999" name="with intercepted network calls Plugins uses plugin for account 99999" time="0.03">
    </testcase>
    <testcase classname="with intercepted network calls Plugins plugins are still queried even if current credentials are expired (or otherwise invalid)" name="with intercepted network calls Plugins plugins are still queried even if current credentials are expired (or otherwise invalid)" time="0.048">
    </testcase>
    <testcase classname="with intercepted network calls Plugins does not use plugins if current credentials are for expected account" name="with intercepted network calls Plugins does not use plugins if current credentials are for expected account" time="0.033">
    </testcase>
    <testcase classname="with intercepted network calls when CDK AssumeRoles assuming a role does not fail when OS username cannot be read" name="with intercepted network calls when CDK AssumeRoles assuming a role does not fail when OS username cannot be read" time="0.037">
    </testcase>
    <testcase classname="with intercepted network calls when CDK AssumeRoles assuming a role sanitizes the username into the session name" name="with intercepted network calls when CDK AssumeRoles assuming a role sanitizes the username into the session name" time="0.069">
    </testcase>
    <testcase classname="with intercepted network calls when CDK AssumeRoles if AssumeRole fails because of ExpiredToken, then fail completely" name="with intercepted network calls when CDK AssumeRoles if AssumeRole fails because of ExpiredToken, then fail completely" time="0.027">
    </testcase>
    <testcase classname="with intercepted network calls when CDK AssumeRoles if AssumeRole fails but current credentials are for the right account, we will still use them" name="with intercepted network calls when CDK AssumeRoles if AssumeRole fails but current credentials are for the right account, we will still use them" time="0.03">
    </testcase>
    <testcase classname="with intercepted network calls when CDK AssumeRoles session tags can be passed when assuming a role" name="with intercepted network calls when CDK AssumeRoles session tags can be passed when assuming a role" time="0.047">
    </testcase>
    <testcase classname="with intercepted network calls when CDK AssumeRoles error we get from assuming a role is useful" name="with intercepted network calls when CDK AssumeRoles error we get from assuming a role is useful" time="0.027">
    </testcase>
    <testcase classname="with intercepted network calls when CDK AssumeRoles even if current credentials are for the wrong account, we will still use them to AssumeRole" name="with intercepted network calls when CDK AssumeRoles even if current credentials are for the wrong account, we will still use them to AssumeRole" time="0.046">
    </testcase>
    <testcase classname="with intercepted network calls when CDK does not AssumeRole uses default credentials by default" name="with intercepted network calls when CDK does not AssumeRole uses default credentials by default" time="0.027">
    </testcase>
    <testcase classname="with intercepted network calls when CDK does not AssumeRole can assume role even if [default] profile is missing" name="with intercepted network calls when CDK does not AssumeRole can assume role even if [default] profile is missing" time="0.021">
    </testcase>
    <testcase classname="with intercepted network calls when CDK does not AssumeRole throws if profile credentials are not for the right account" name="with intercepted network calls when CDK does not AssumeRole throws if profile credentials are not for the right account" time="0.02">
    </testcase>
    <testcase classname="with intercepted network calls when CDK does not AssumeRole supports profile spread over config_file and credentials_file" name="with intercepted network calls when CDK does not AssumeRole supports profile spread over config_file and credentials_file" time="0.022">
    </testcase>
    <testcase classname="with intercepted network calls when CDK does not AssumeRole mfa_serial in profile will ask user for token" name="with intercepted network calls when CDK does not AssumeRole mfa_serial in profile will ask user for token" time="0.035">
    </testcase>
    <testcase classname="with intercepted network calls when CDK does not AssumeRole no base credentials partition if token is expired" name="with intercepted network calls when CDK does not AssumeRole no base credentials partition if token is expired" time="0.001">
    </testcase>
    <testcase classname="with intercepted network calls when CDK does not AssumeRole can assume-role configured in config" name="with intercepted network calls when CDK does not AssumeRole can assume-role configured in config" time="0.04">
    </testcase>
    <testcase classname="with intercepted network calls when CDK does not AssumeRole supports profile only in config_file" name="with intercepted network calls when CDK does not AssumeRole supports profile only in config_file" time="0.024">
    </testcase>
    <testcase classname="with intercepted network calls when CDK does not AssumeRole passing profile skips EnvironmentCredentials" name="with intercepted network calls when CDK does not AssumeRole passing profile skips EnvironmentCredentials" time="0.018">
    </testcase>
    <testcase classname="with intercepted network calls when CDK does not AssumeRole mfa_serial in profile will ask user for token" name="with intercepted network calls when CDK does not AssumeRole mfa_serial in profile will ask user for token" time="0.029">
    </testcase>
    <testcase classname="with intercepted network calls when CDK does not AssumeRole use profile acct/region if agnostic env requested" name="with intercepted network calls when CDK does not AssumeRole use profile acct/region if agnostic env requested" time="0.022">
    </testcase>
    <testcase classname="with intercepted network calls when CDK does not AssumeRole throws if no credentials could be found" name="with intercepted network calls when CDK does not AssumeRole throws if no credentials could be found" time="0.005">
    </testcase>
    <testcase classname="with intercepted network calls defaultAccount returns undefined if STS call fails" name="with intercepted network calls defaultAccount returns undefined if STS call fails" time="0.003">
    </testcase>
    <testcase classname=" default useragent is reasonable" name=" default useragent is reasonable" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="CloudFormation API calls" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:40:49" time="4.323" tests="27">
    <testcase classname="CloudFormation API calls parameter hashes are included" name="CloudFormation API calls parameter hashes are included" time="0.015">
    </testcase>
    <testcase classname="CloudFormation API calls bootstrap filters out other bootstrap versions" name="CloudFormation API calls bootstrap filters out other bootstrap versions" time="0.015">
    </testcase>
    <testcase classname="BackgroundStackRefresh should wait for the next refresh if called within time frame" name="BackgroundStackRefresh should wait for the next refresh if called within time frame" time="0.004">
    </testcase>
    <testcase classname="BackgroundStackRefresh should start after a delay" name="BackgroundStackRefresh should start after a delay" time="0.004">
    </testcase>
    <testcase classname="BackgroundStackRefresh should reject if the refresh takes too long" name="BackgroundStackRefresh should reject if the refresh takes too long" time="0.023">
    </testcase>
    <testcase classname="BackgroundStackRefresh should wait for the next refresh if refresh lands before the timeout" name="BackgroundStackRefresh should wait for the next refresh if refresh lands before the timeout" time="0.003">
    </testcase>
    <testcase classname="BackgroundStackRefresh should refresh stacks and schedule next refresh" name="BackgroundStackRefresh should refresh stacks and schedule next refresh" time="0.006">
    </testcase>
    <testcase classname="ProgressPrinter throws if start is called twice without stop" name="ProgressPrinter throws if start is called twice without stop" time="0.011">
    </testcase>
    <testcase classname="ECR Garbage Collection listImagesCommand returns nextToken" name="ECR Garbage Collection listImagesCommand returns nextToken" time="0.01">
    </testcase>
    <testcase classname="ECR Garbage Collection action = tag -- does not delete" name="ECR Garbage Collection action = tag -- does not delete" time="0.005">
    </testcase>
    <testcase classname="ECR Garbage Collection rollbackBufferDays = 0 -- assets to be deleted" name="ECR Garbage Collection rollbackBufferDays = 0 -- assets to be deleted" time="0.009">
    </testcase>
    <testcase classname="ECR Garbage Collection ignore images that are modified after gc start" name="ECR Garbage Collection ignore images that are modified after gc start" time="0.006">
    </testcase>
    <testcase classname="ECR Garbage Collection rollbackBufferDays &gt; 0 -- assets to be tagged" name="ECR Garbage Collection rollbackBufferDays &gt; 0 -- assets to be tagged" time="0.006">
    </testcase>
    <testcase classname="ECR Garbage Collection createdAtBufferDays &gt; 0" name="ECR Garbage Collection createdAtBufferDays &gt; 0" time="0.007">
    </testcase>
    <testcase classname="ECR Garbage Collection tags are unique" name="ECR Garbage Collection tags are unique" time="0.005">
    </testcase>
    <testcase classname="ECR Garbage Collection action = delete-tagged -- does not tag" name="ECR Garbage Collection action = delete-tagged -- does not tag" time="0.004">
    </testcase>
    <testcase classname="ECR Garbage Collection action = print -- does not tag or delete" name="ECR Garbage Collection action = print -- does not tag or delete" time="0.003">
    </testcase>
    <testcase classname="ECR Garbage Collection succeeds when no images are present" name="ECR Garbage Collection succeeds when no images are present" time="0.004">
    </testcase>
    <testcase classname="Garbage Collection with large # of objects tag only" name="Garbage Collection with large # of objects tag only" time="2.099">
    </testcase>
    <testcase classname="Garbage Collection with large # of objects delete-tagged only" name="Garbage Collection with large # of objects delete-tagged only" time="1.232">
    </testcase>
    <testcase classname="S3 Garbage Collection rollbackBufferDays &gt; 0 -- assets to be tagged" name="S3 Garbage Collection rollbackBufferDays &gt; 0 -- assets to be tagged" time="0.004">
    </testcase>
    <testcase classname="S3 Garbage Collection action = tag -- does not delete" name="S3 Garbage Collection action = tag -- does not delete" time="0.003">
    </testcase>
    <testcase classname="S3 Garbage Collection ignore objects that are modified after gc start" name="S3 Garbage Collection ignore objects that are modified after gc start" time="0.003">
    </testcase>
    <testcase classname="S3 Garbage Collection rollbackBufferDays = 0 -- assets to be deleted" name="S3 Garbage Collection rollbackBufferDays = 0 -- assets to be deleted" time="0.003">
    </testcase>
    <testcase classname="S3 Garbage Collection createdAtBufferDays &gt; 0" name="S3 Garbage Collection createdAtBufferDays &gt; 0" time="0.004">
    </testcase>
    <testcase classname="S3 Garbage Collection action = print -- does not tag or delete" name="S3 Garbage Collection action = print -- does not tag or delete" time="0.005">
    </testcase>
    <testcase classname="S3 Garbage Collection action = delete-tagged -- does not tag" name="S3 Garbage Collection action = delete-tagged -- does not tag" time="0.005">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:40:49" time="4.554" tests="9">
    <testcase classname=" get(k) when cache is empty" name=" get(k) when cache is empty" time="0.021">
    </testcase>
    <testcase classname="using cache file gets cached value" name="using cache file gets cached value" time="0.014">
    </testcase>
    <testcase classname="using cache file uses the resolver when the file cannot be read" name="using cache file uses the resolver when the file cannot be read" time="0.007">
    </testcase>
    <testcase classname=" account cache does not fail when given a nonwritable directory" name=" account cache does not fail when given a nonwritable directory" time="0.006">
    </testcase>
    <testcase classname=" cache is nuked if it exceeds 1000 entries" name=" cache is nuked if it exceeds 1000 entries" time="3.432">
    </testcase>
    <testcase classname=" fetch(k, resolver) can be used to &quot;atomically&quot; get + resolve + put" name=" fetch(k, resolver) can be used to &quot;atomically&quot; get + resolve + put" time="0.004">
    </testcase>
    <testcase classname=" put(k,v) and then get(k)" name=" put(k,v) and then get(k)" time="0.006">
    </testcase>
    <testcase classname=" default account cache uses CDK_HOME" name=" default account cache uses CDK_HOME" time="0">
    </testcase>
    <testcase classname=" cache pretends to be empty if cache file does not contain JSON" name=" cache pretends to be empty if cache file does not contain JSON" time="0.006">
    </testcase>
  </testsuite>
  <testsuite name="exec verbose flag tests" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:40:48" time="6.139" tests="6">
    <testcase classname="exec verbose flag tests should set DEBUG level with single -v flag" name="exec verbose flag tests should set DEBUG level with single -v flag" time="2.019">
    </testcase>
    <testcase classname="exec verbose flag tests should set DEBUG level with --verbose=1" name="exec verbose flag tests should set DEBUG level with --verbose=1" time="2.007">
    </testcase>
    <testcase classname="exec verbose flag tests should set TRACE level with --verbose=2" name="exec verbose flag tests should set TRACE level with --verbose=2" time="1.012">
    </testcase>
    <testcase classname="exec verbose flag tests should not set log level when no verbose flag is present" name="exec verbose flag tests should not set log level when no verbose flag is present" time="0.008">
    </testcase>
    <testcase classname="exec verbose flag tests should set TRACE level with verbose level &gt; 2" name="exec verbose flag tests should set TRACE level with verbose level &gt; 2" time="0.011">
    </testcase>
    <testcase classname="exec verbose flag tests should set TRACE level with double -v flag" name="exec verbose flag tests should set TRACE level with double -v flag" time="0.005">
    </testcase>
  </testsuite>
  <testsuite name="Notices" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:40:47" time="6.584" tests="40">
    <testcase classname="Notices addBootstrapVersion deduplicates" name="Notices addBootstrapVersion deduplicates" time="0.002">
    </testcase>
    <testcase classname="Notices addBootstrapVersion can add multiple values" name="Notices addBootstrapVersion can add multiple values" time="0.008">
    </testcase>
    <testcase classname="Notices display total count when show total is true" name="Notices display total count when show total is true" time="0.001">
    </testcase>
    <testcase classname="Notices display warning" name="Notices display warning" time="0.003">
    </testcase>
    <testcase classname="Notices display deduplicates notices" name="Notices display deduplicates notices" time="0">
    </testcase>
    <testcase classname="Notices display notices envelop" name="Notices display notices envelop" time="0.001">
    </testcase>
    <testcase classname="Notices display does nothing when we shouldnt display" name="Notices display does nothing when we shouldnt display" time="0">
    </testcase>
    <testcase classname="Notices display only unacknowledged notices" name="Notices display only unacknowledged notices" time="0">
    </testcase>
    <testcase classname="Notices display can include acknowledged notices if requested" name="Notices display can include acknowledged notices if requested" time="0.004">
    </testcase>
    <testcase classname="Notices display only relevant notices" name="Notices display only relevant notices" time="0.001">
    </testcase>
    <testcase classname="Notices display nothing when there are no notices" name="Notices display nothing when there are no notices" time="0">
    </testcase>
    <testcase classname="Notices display error" name="Notices display error" time="0">
    </testcase>
    <testcase classname="Notices refresh filters out acknowledged notices by default" name="Notices refresh filters out acknowledged notices by default" time="0.001">
    </testcase>
    <testcase classname="Notices refresh clears notices if empty" name="Notices refresh clears notices if empty" time="0">
    </testcase>
    <testcase classname="Notices refresh deduplicates notices" name="Notices refresh deduplicates notices" time="0">
    </testcase>
    <testcase classname="Notices refresh preserves acknowledged notices if requested" name="Notices refresh preserves acknowledged notices if requested" time="0.001">
    </testcase>
    <testcase classname="Notices refresh doesnt throw" name="Notices refresh doesnt throw" time="0">
    </testcase>
    <testcase classname="Notices refresh does nothing when we shouldnt display" name="Notices refresh does nothing when we shouldnt display" time="0.001">
    </testcase>
    <testcase classname="FilteredNotice format resolves dynamic values" name="FilteredNotice format resolves dynamic values" time="0.001">
    </testcase>
    <testcase classname="FilteredNotice format multiple version ranges" name="FilteredNotice format multiple version ranges" time="0">
    </testcase>
    <testcase classname="FilteredNotice format single version range" name="FilteredNotice format single version range" time="0">
    </testcase>
    <testcase classname="NoticesFilter filter cli" name="NoticesFilter filter cli" time="0.003">
    </testcase>
    <testcase classname="NoticesFilter filter framework" name="NoticesFilter filter framework" time="0.002">
    </testcase>
    <testcase classname="NoticesFilter filter bootstrap" name="NoticesFilter filter bootstrap" time="0">
    </testcase>
    <testcase classname="NoticesFilter filter ignores invalid bootstrap versions" name="NoticesFilter filter ignores invalid bootstrap versions" time="0.001">
    </testcase>
    <testcase classname="NoticesFilter filter module" name="NoticesFilter filter module" time="0.002">
    </testcase>
    <testcase classname="CachedDataSource retrieves data from the file when the data is still valid" name="CachedDataSource retrieves data from the file when the data is still valid" time="0.013">
    </testcase>
    <testcase classname="CachedDataSource retrieves data from the delegate when the data is expired" name="CachedDataSource retrieves data from the delegate when the data is expired" time="0.01">
    </testcase>
    <testcase classname="CachedDataSource retrieves data from the delegate cache when the file is empty" name="CachedDataSource retrieves data from the delegate cache when the file is empty" time="0.009">
    </testcase>
    <testcase classname="CachedDataSource retrieves data from the delegate when the file cannot be read" name="CachedDataSource retrieves data from the delegate when the file cannot be read" time="0.006">
    </testcase>
    <testcase classname="CachedDataSource error in delegate gets turned into empty result by cached source" name="CachedDataSource error in delegate gets turned into empty result by cached source" time="0.002">
    </testcase>
    <testcase classname="CachedDataSource retrieved data from the delegate when it is configured to ignore the cache" name="CachedDataSource retrieved data from the delegate when it is configured to ignore the cache" time="0.003">
    </testcase>
    <testcase classname="WebsiteNoticeDataSource returns appropriate error when the server returns an unexpected structure" name="WebsiteNoticeDataSource returns appropriate error when the server returns an unexpected structure" time="0.035">
    </testcase>
    <testcase classname="WebsiteNoticeDataSource returns appropriate error when the request has an error" name="WebsiteNoticeDataSource returns appropriate error when the request has an error" time="0.006">
    </testcase>
    <testcase classname="WebsiteNoticeDataSource returns appropriate error when HTTPS call throws" name="WebsiteNoticeDataSource returns appropriate error when HTTPS call throws" time="0.014">
    </testcase>
    <testcase classname="WebsiteNoticeDataSource returns appropriate error when the connection stays idle for too long" name="WebsiteNoticeDataSource returns appropriate error when the connection stays idle for too long" time="3.001">
    </testcase>
    <testcase classname="WebsiteNoticeDataSource returns appropriate error when the server returns an unexpected status code" name="WebsiteNoticeDataSource returns appropriate error when the server returns an unexpected status code" time="0.01">
    </testcase>
    <testcase classname="WebsiteNoticeDataSource returns appropriate error when the server returns invalid json" name="WebsiteNoticeDataSource returns appropriate error when the server returns invalid json" time="0.005">
    </testcase>
    <testcase classname="WebsiteNoticeDataSource returns data when download succeeds" name="WebsiteNoticeDataSource returns data when download succeeds" time="0.004">
    </testcase>
    <testcase classname="WebsiteNoticeDataSource returns empty array when the request takes too long to finish" name="WebsiteNoticeDataSource returns empty array when the request takes too long to finish" time="3.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:40:53" time="1.628" tests="20">
    <testcase classname=" readCurrentTemplateWithNestedStacks() successfully ignores stacks without metadata" name=" readCurrentTemplateWithNestedStacks() successfully ignores stacks without metadata" time="0.019">
    </testcase>
    <testcase classname=" role with placeholders is assumed if assumerole is given" name=" role with placeholders is assumed if assumerole is given" time="0.012">
    </testcase>
    <testcase classname=" readCurrentTemplateWithNestedStacks() with a 3-level nested + sibling structure works" name=" readCurrentTemplateWithNestedStacks() with a 3-level nested + sibling structure works" time="0.019">
    </testcase>
    <testcase classname=" readCurrentTemplateWithNestedStacks() on an undeployed parent stack with an (also undeployed) nested stack works" name=" readCurrentTemplateWithNestedStacks() on an undeployed parent stack with an (also undeployed) nested stack works" time="0.013">
    </testcase>
    <testcase classname=" readCurrentTemplateWithNestedStacks() can handle non-Resources in the template" name=" readCurrentTemplateWithNestedStacks() can handle non-Resources in the template" time="0.009">
    </testcase>
    <testcase classname=" readCurrentTemplateWithNestedStacks() caches calls to listStackResources()" name=" readCurrentTemplateWithNestedStacks() caches calls to listStackResources()" time="0.008">
    </testcase>
    <testcase classname=" rollback stack allows continue rollback from UPDATE_ROLLBACK_FAILED" name=" rollback stack allows continue rollback from UPDATE_ROLLBACK_FAILED" time="0.013">
    </testcase>
    <testcase classname=" if toolkit stack be found: true but SSM parameter name is present deployment succeeds" name=" if toolkit stack be found: true but SSM parameter name is present deployment succeeds" time="0.097">
    </testcase>
    <testcase classname=" continue rollback stack with force ignores any failed resources" name=" continue rollback stack with force ignores any failed resources" time="0.008">
    </testcase>
    <testcase classname=" tags are passed along to create change set" name=" tags are passed along to create change set" time="0.005">
    </testcase>
    <testcase classname=" rollback stack allows rolling back from UPDATE_FAILED" name=" rollback stack allows rolling back from UPDATE_FAILED" time="0.011">
    </testcase>
    <testcase classname="stackExists uses lookup role if requested: false" name="stackExists uses lookup role if requested: false" time="0.012">
    </testcase>
    <testcase classname="stackExists uses lookup role if requested: true" name="stackExists uses lookup role if requested: true" time="0.008">
    </testcase>
    <testcase classname=" placeholders are substituted in CloudFormation execution role" name=" placeholders are substituted in CloudFormation execution role" time="0.013">
    </testcase>
    <testcase classname=" rollback stack assumes role if necessary" name=" rollback stack assumes role if necessary" time="0.009">
    </testcase>
    <testcase classname=" deployment fails if bootstrap stack is missing" name=" deployment fails if bootstrap stack is missing" time="0.029">
    </testcase>
    <testcase classname=" rollback stack fails in UPDATE_COMPLETE state" name=" rollback stack fails in UPDATE_COMPLETE state" time="0.008">
    </testcase>
    <testcase classname=" if toolkit stack be found: false but SSM parameter name is present deployment succeeds" name=" if toolkit stack be found: false but SSM parameter name is present deployment succeeds" time="0.015">
    </testcase>
    <testcase classname=" deployment fails if bootstrap stack is too old" name=" deployment fails if bootstrap stack is too old" time="0.017">
    </testcase>
    <testcase classname=" passes through hotswap=true to deployStack()" name=" passes through hotswap=true to deployStack()" time="0.007">
    </testcase>
  </testsuite>
  <testsuite name="&quot;fall-back&quot; mode" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:40:45" time="9.698" tests="50">
    <testcase classname="&quot;fall-back&quot; mode when it receives a change that is not a mapping template difference in a Function, it does not call the updateFunction() API in CLASSIC mode
        but does in HOTSWAP_ONLY mode" name="&quot;fall-back&quot; mode when it receives a change that is not a mapping template difference in a Function, it does not call the updateFunction() API in CLASSIC mode
        but does in HOTSWAP_ONLY mode" time="0.489">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode calls the updateApiKey() API when it receives only a expires property difference in an AppSync ApiKey" name="&quot;fall-back&quot; mode calls the updateApiKey() API when it receives only a expires property difference in an AppSync ApiKey" time="0.02">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode calls the startSchemaCreation() and throws if schema creation fails" name="&quot;fall-back&quot; mode calls the startSchemaCreation() and throws if schema creation fails" time="1.04">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode when it receives a change that is not a mapping template difference in a Resolver, it does not call the updateResolver() API in CLASSIC mode
        but does call the updateResolver() API in HOTSWAP_ONLY mode" name="&quot;fall-back&quot; mode when it receives a change that is not a mapping template difference in a Resolver, it does not call the updateResolver() API in CLASSIC mode
        but does call the updateResolver() API in HOTSWAP_ONLY mode" time="0.017">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode calls the updateFunction() API with runtime when it receives both function version and runtime with code in a Function" name="&quot;fall-back&quot; mode calls the updateFunction() API with runtime when it receives both function version and runtime with code in a Function" time="0.015">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode does not call the updateResolver() API when a resource with type that is not AWS::AppSync::Resolver but has the same properties is changed" name="&quot;fall-back&quot; mode does not call the updateResolver() API when a resource with type that is not AWS::AppSync::Resolver but has the same properties is changed" time="0.012">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode calls the updateResolver() API when it receives only a mapping template difference s3 location in a Unit Resolver" name="&quot;fall-back&quot; mode calls the updateResolver() API when it receives only a mapping template difference s3 location in a Unit Resolver" time="0.019">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode A new Resolver being added to the Stack returns undefined in CLASSIC mode and
        returns a noOp in HOTSWAP_ONLY mode" name="&quot;fall-back&quot; mode A new Resolver being added to the Stack returns undefined in CLASSIC mode and
        returns a noOp in HOTSWAP_ONLY mode" time="0.013">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode calls the updateFunction() API with functionId when function is listed on second page" name="&quot;fall-back&quot; mode calls the updateFunction() API with functionId when function is listed on second page" time="0.017">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode calls the updateResolver() API when it receives only a mapping template difference in a Unit Resolver" name="&quot;fall-back&quot; mode calls the updateResolver() API when it receives only a mapping template difference in a Unit Resolver" time="0.021">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode calls the updateResolver() API when it receives only a mapping template difference in a Pipeline Resolver" name="&quot;fall-back&quot; mode calls the updateResolver() API when it receives only a mapping template difference in a Pipeline Resolver" time="0.016">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode calls the startSchemaCreation() API when it receives only a definition s3 location difference in a graphql schema" name="&quot;fall-back&quot; mode calls the startSchemaCreation() API when it receives only a definition s3 location difference in a graphql schema" time="0.016">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode calls the startSchemaCreation() API when it receives only a definition difference in a graphql schema" name="&quot;fall-back&quot; mode calls the startSchemaCreation() API when it receives only a definition difference in a graphql schema" time="0.021">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode updateFunction() API fails if it recieves 7 failed attempts in a row" name="&quot;fall-back&quot; mode updateFunction() API fails if it recieves 7 failed attempts in a row" time="0.07">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode calls the startSchemaCreation() and waits for schema creation to stabilize before finishing" name="&quot;fall-back&quot; mode calls the startSchemaCreation() and waits for schema creation to stabilize before finishing" time="1.019">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode calls the updateFunction() API when it receives only a mapping template s3 location difference in a Function" name="&quot;fall-back&quot; mode calls the updateFunction() API when it receives only a mapping template s3 location difference in a Function" time="0.009">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode updateFunction() API recovers from failed update attempt through retry logic" name="&quot;fall-back&quot; mode updateFunction() API recovers from failed update attempt through retry logic" time="1.011">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode calls the updateFunction() API with function version when it receives both function version and runtime with a mapping template in a Function" name="&quot;fall-back&quot; mode calls the updateFunction() API with function version when it receives both function version and runtime with a mapping template in a Function" time="0.011">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode does not call the updateFunction() API when a resource with type that is not AWS::AppSync::FunctionConfiguration but has the same properties is changed" name="&quot;fall-back&quot; mode does not call the updateFunction() API when a resource with type that is not AWS::AppSync::FunctionConfiguration but has the same properties is changed" time="0.009">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode calls the updateResolver() API when it receives only a code difference in a Pipeline Resolver" name="&quot;fall-back&quot; mode calls the updateResolver() API when it receives only a code difference in a Pipeline Resolver" time="0.01">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode calls the updateResolver() API when it receives only a code s3 location in a Pipeline Resolver" name="&quot;fall-back&quot; mode calls the updateResolver() API when it receives only a code s3 location in a Pipeline Resolver" time="0.009">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode calls the updateApiKey() API when it receives only a expires property difference and no api-key-id in an AppSync ApiKey" name="&quot;fall-back&quot; mode calls the updateApiKey() API when it receives only a expires property difference and no api-key-id in an AppSync ApiKey" time="0.008">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode does not call startSchemaCreation() API when a resource with type that is not AWS::AppSync::GraphQLSchema but has the same properties is change" name="&quot;fall-back&quot; mode does not call startSchemaCreation() API when a resource with type that is not AWS::AppSync::GraphQLSchema but has the same properties is change" time="0.009">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode calls the updateFunction() API when it receives only a mapping template difference in a Function" name="&quot;fall-back&quot; mode calls the updateFunction() API when it receives only a mapping template difference in a Function" time="0.01">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode calls the startSchemaCreation() API when it receives only a definition difference in a graphql schema" name="&quot;fall-back&quot; mode calls the startSchemaCreation() API when it receives only a definition difference in a graphql schema" time="0.008">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode calls the updateResolver() API when it receives only a mapping template difference in a Unit Resolver" name="&quot;hotswap-only&quot; mode calls the updateResolver() API when it receives only a mapping template difference in a Unit Resolver" time="0.009">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode updateFunction() API fails if it recieves 7 failed attempts in a row" name="&quot;hotswap-only&quot; mode updateFunction() API fails if it recieves 7 failed attempts in a row" time="0.019">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode calls the updateFunction() API with function version when it receives both function version and runtime with a mapping template in a Function" name="&quot;hotswap-only&quot; mode calls the updateFunction() API with function version when it receives both function version and runtime with a mapping template in a Function" time="0.009">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode does not call the updateFunction() API when a resource with type that is not AWS::AppSync::FunctionConfiguration but has the same properties is changed" name="&quot;hotswap-only&quot; mode does not call the updateFunction() API when a resource with type that is not AWS::AppSync::FunctionConfiguration but has the same properties is changed" time="0.006">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode calls the updateFunction() API with functionId when function is listed on second page" name="&quot;hotswap-only&quot; mode calls the updateFunction() API with functionId when function is listed on second page" time="0.008">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode calls the updateResolver() API when it receives only a code s3 location in a Pipeline Resolver" name="&quot;hotswap-only&quot; mode calls the updateResolver() API when it receives only a code s3 location in a Pipeline Resolver" time="0.009">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode calls the updateFunction() API when it receives only a mapping template s3 location difference in a Function" name="&quot;hotswap-only&quot; mode calls the updateFunction() API when it receives only a mapping template s3 location difference in a Function" time="0.01">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode calls the startSchemaCreation() API when it receives only a definition difference in a graphql schema" name="&quot;hotswap-only&quot; mode calls the startSchemaCreation() API when it receives only a definition difference in a graphql schema" time="0.009">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode calls the startSchemaCreation() and throws if schema creation fails" name="&quot;hotswap-only&quot; mode calls the startSchemaCreation() and throws if schema creation fails" time="1.01">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode does not call startSchemaCreation() API when a resource with type that is not AWS::AppSync::GraphQLSchema but has the same properties is change" name="&quot;hotswap-only&quot; mode does not call startSchemaCreation() API when a resource with type that is not AWS::AppSync::GraphQLSchema but has the same properties is change" time="0.011">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode when it receives a change that is not a mapping template difference in a Resolver, it does not call the updateResolver() API in CLASSIC mode
        but does call the updateResolver() API in HOTSWAP_ONLY mode" name="&quot;hotswap-only&quot; mode when it receives a change that is not a mapping template difference in a Resolver, it does not call the updateResolver() API in CLASSIC mode
        but does call the updateResolver() API in HOTSWAP_ONLY mode" time="0.007">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode calls the updateFunction() API with runtime when it receives both function version and runtime with code in a Function" name="&quot;hotswap-only&quot; mode calls the updateFunction() API with runtime when it receives both function version and runtime with code in a Function" time="0.007">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode calls the updateResolver() API when it receives only a code difference in a Pipeline Resolver" name="&quot;hotswap-only&quot; mode calls the updateResolver() API when it receives only a code difference in a Pipeline Resolver" time="0.017">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode does not call the updateResolver() API when a resource with type that is not AWS::AppSync::Resolver but has the same properties is changed" name="&quot;hotswap-only&quot; mode does not call the updateResolver() API when a resource with type that is not AWS::AppSync::Resolver but has the same properties is changed" time="0.011">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode A new Resolver being added to the Stack returns undefined in CLASSIC mode and
        returns a noOp in HOTSWAP_ONLY mode" name="&quot;hotswap-only&quot; mode A new Resolver being added to the Stack returns undefined in CLASSIC mode and
        returns a noOp in HOTSWAP_ONLY mode" time="0.009">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode calls the startSchemaCreation() and waits for schema creation to stabilize before finishing" name="&quot;hotswap-only&quot; mode calls the startSchemaCreation() and waits for schema creation to stabilize before finishing" time="1.012">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode when it receives a change that is not a mapping template difference in a Function, it does not call the updateFunction() API in CLASSIC mode
        but does in HOTSWAP_ONLY mode" name="&quot;hotswap-only&quot; mode when it receives a change that is not a mapping template difference in a Function, it does not call the updateFunction() API in CLASSIC mode
        but does in HOTSWAP_ONLY mode" time="0.01">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode updateFunction() API recovers from failed update attempt through retry logic" name="&quot;hotswap-only&quot; mode updateFunction() API recovers from failed update attempt through retry logic" time="1.014">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode calls the updateResolver() API when it receives only a mapping template difference s3 location in a Unit Resolver" name="&quot;hotswap-only&quot; mode calls the updateResolver() API when it receives only a mapping template difference s3 location in a Unit Resolver" time="0.016">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode calls the startSchemaCreation() API when it receives only a definition difference in a graphql schema" name="&quot;hotswap-only&quot; mode calls the startSchemaCreation() API when it receives only a definition difference in a graphql schema" time="0.01">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode calls the updateApiKey() API when it receives only a expires property difference in an AppSync ApiKey" name="&quot;hotswap-only&quot; mode calls the updateApiKey() API when it receives only a expires property difference in an AppSync ApiKey" time="0.008">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode calls the startSchemaCreation() API when it receives only a definition s3 location difference in a graphql schema" name="&quot;hotswap-only&quot; mode calls the startSchemaCreation() API when it receives only a definition s3 location difference in a graphql schema" time="0.014">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode calls the updateApiKey() API when it receives only a expires property difference and no api-key-id in an AppSync ApiKey" name="&quot;hotswap-only&quot; mode calls the updateApiKey() API when it receives only a expires property difference and no api-key-id in an AppSync ApiKey" time="0.014">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode calls the updateFunction() API when it receives only a mapping template difference in a Function" name="&quot;hotswap-only&quot; mode calls the updateFunction() API when it receives only a mapping template difference in a Function" time="0.012">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode calls the updateResolver() API when it receives only a mapping template difference in a Pipeline Resolver" name="&quot;hotswap-only&quot; mode calls the updateResolver() API when it receives only a mapping template difference in a Pipeline Resolver" time="0.011">
    </testcase>
  </testsuite>
  <testsuite name="&quot;fall-back&quot; mode" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:40:53" time="2.355" tests="26">
    <testcase classname="&quot;fall-back&quot; mode can hotswap a lambda function in a 1-level nested stack with asset parameters" name="&quot;fall-back&quot; mode can hotswap a lambda function in a 1-level nested stack with asset parameters" time="0.556">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode can hotswap a lambda function in a 2-level nested stack with asset parameters" name="&quot;fall-back&quot; mode can hotswap a lambda function in a 2-level nested stack with asset parameters" time="0.04">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode can hotswap a lambda function in a 2-level nested stack with dependency on an output of 2nd level sibling stack" name="&quot;fall-back&quot; mode can hotswap a lambda function in a 2-level nested stack with dependency on an output of 2nd level sibling stack" time="0.075">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode can hotswap a lambda function in a 1-level nested stack and read default parameters value if not provided" name="&quot;fall-back&quot; mode can hotswap a lambda function in a 1-level nested stack and read default parameters value if not provided" time="0.03">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode deleting a nested stack results in a full deployment in CLASSIC mode, even if their parent contains a hotswappable change,
        but results in a hotswap deployment in HOTSWAP_ONLY mode" name="&quot;fall-back&quot; mode deleting a nested stack results in a full deployment in CLASSIC mode, even if their parent contains a hotswappable change,
        but results in a hotswap deployment in HOTSWAP_ONLY mode" time="0.03">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode hotswappable changes do not override hotswappable changes in their ancestors" name="&quot;fall-back&quot; mode hotswappable changes do not override hotswappable changes in their ancestors" time="0.033">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode can hotswap a lambda function in a 1-level nested stack" name="&quot;fall-back&quot; mode can hotswap a lambda function in a 1-level nested stack" time="0.046">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode looking up objects in nested stacks works" name="&quot;fall-back&quot; mode looking up objects in nested stacks works" time="0.067">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode multi-sibling + 3-layer nested stack structure is hotswappable" name="&quot;fall-back&quot; mode multi-sibling + 3-layer nested stack structure is hotswappable" time="0.055">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode creating a nested stack results in a full deployment in CLASSIC mode, even if their parent contains a hotswappable change,
        but results in a hotswap deployment in HOTSWAP_ONLY mode" name="&quot;fall-back&quot; mode creating a nested stack results in a full deployment in CLASSIC mode, even if their parent contains a hotswappable change,
        but results in a hotswap deployment in HOTSWAP_ONLY mode" time="0.062">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode attempting to hotswap a newly created nested stack with the same logical ID as a resource with a different type results in a full deployment in CLASSIC mode
        and a hotswap deployment in HOTSWAP_ONLY mode" name="&quot;fall-back&quot; mode attempting to hotswap a newly created nested stack with the same logical ID as a resource with a different type results in a full deployment in CLASSIC mode
        and a hotswap deployment in HOTSWAP_ONLY mode" time="0.013">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode hotswappable changes in nested stacks do not override hotswappable changes in their parent stack" name="&quot;fall-back&quot; mode hotswappable changes in nested stacks do not override hotswappable changes in their parent stack" time="0.019">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode non-hotswappable changes in nested stacks result in a full deployment, even if their parent contains a hotswappable change in CLASSIC mode,
        but perform a hotswap deployment in HOTSWAP_ONLY" name="&quot;fall-back&quot; mode non-hotswappable changes in nested stacks result in a full deployment, even if their parent contains a hotswappable change in CLASSIC mode,
        but perform a hotswap deployment in HOTSWAP_ONLY" time="0.016">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode can hotswap a lambda function in a 2-level nested stack with asset parameters" name="&quot;hotswap-only&quot; mode can hotswap a lambda function in a 2-level nested stack with asset parameters" time="0.021">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode looking up objects in nested stacks works" name="&quot;hotswap-only&quot; mode looking up objects in nested stacks works" time="0.021">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode deleting a nested stack results in a full deployment in CLASSIC mode, even if their parent contains a hotswappable change,
        but results in a hotswap deployment in HOTSWAP_ONLY mode" name="&quot;hotswap-only&quot; mode deleting a nested stack results in a full deployment in CLASSIC mode, even if their parent contains a hotswappable change,
        but results in a hotswap deployment in HOTSWAP_ONLY mode" time="0.015">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode can hotswap a lambda function in a 1-level nested stack" name="&quot;hotswap-only&quot; mode can hotswap a lambda function in a 1-level nested stack" time="0.015">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode can hotswap a lambda function in a 1-level nested stack with asset parameters" name="&quot;hotswap-only&quot; mode can hotswap a lambda function in a 1-level nested stack with asset parameters" time="0.018">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode non-hotswappable changes in nested stacks result in a full deployment, even if their parent contains a hotswappable change in CLASSIC mode,
        but perform a hotswap deployment in HOTSWAP_ONLY" name="&quot;hotswap-only&quot; mode non-hotswappable changes in nested stacks result in a full deployment, even if their parent contains a hotswappable change in CLASSIC mode,
        but perform a hotswap deployment in HOTSWAP_ONLY" time="0.02">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode creating a nested stack results in a full deployment in CLASSIC mode, even if their parent contains a hotswappable change,
        but results in a hotswap deployment in HOTSWAP_ONLY mode" name="&quot;hotswap-only&quot; mode creating a nested stack results in a full deployment in CLASSIC mode, even if their parent contains a hotswappable change,
        but results in a hotswap deployment in HOTSWAP_ONLY mode" time="0.023">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode attempting to hotswap a newly created nested stack with the same logical ID as a resource with a different type results in a full deployment in CLASSIC mode
        and a hotswap deployment in HOTSWAP_ONLY mode" name="&quot;hotswap-only&quot; mode attempting to hotswap a newly created nested stack with the same logical ID as a resource with a different type results in a full deployment in CLASSIC mode
        and a hotswap deployment in HOTSWAP_ONLY mode" time="0.022">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode can hotswap a lambda function in a 2-level nested stack with dependency on an output of 2nd level sibling stack" name="&quot;hotswap-only&quot; mode can hotswap a lambda function in a 2-level nested stack with dependency on an output of 2nd level sibling stack" time="0.026">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode hotswappable changes in nested stacks do not override hotswappable changes in their parent stack" name="&quot;hotswap-only&quot; mode hotswappable changes in nested stacks do not override hotswappable changes in their parent stack" time="0.024">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode hotswappable changes do not override hotswappable changes in their ancestors" name="&quot;hotswap-only&quot; mode hotswappable changes do not override hotswappable changes in their ancestors" time="0.038">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode can hotswap a lambda function in a 1-level nested stack and read default parameters value if not provided" name="&quot;hotswap-only&quot; mode can hotswap a lambda function in a 1-level nested stack and read default parameters value if not provided" time="0.014">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode multi-sibling + 3-layer nested stack structure is hotswappable" name="&quot;hotswap-only&quot; mode multi-sibling + 3-layer nested stack structure is hotswappable" time="0.032">
    </testcase>
  </testsuite>
  <testsuite name="&quot;fall-back&quot; mode" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:40:54" time="2.486" tests="36">
    <testcase classname="&quot;fall-back&quot; mode calls waiter after function code is updated and VpcId is empty string with delay 1" name="&quot;fall-back&quot; mode calls waiter after function code is updated and VpcId is empty string with delay 1" time="0.566">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode calls both updateLambdaCode() and updateLambdaConfiguration() API when it receives both code and configuration change" name="&quot;fall-back&quot; mode calls both updateLambdaCode() and updateLambdaConfiguration() API when it receives both code and configuration change" time="0.011">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode correctly evaluates the function&apos;s name when it references a different resource from the template" name="&quot;fall-back&quot; mode correctly evaluates the function&apos;s name when it references a different resource from the template" time="0.012">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode calls the updateLambdaCode() API when it receives only a code difference in a Lambda function" name="&quot;fall-back&quot; mode calls the updateLambdaCode() API when it receives only a code difference in a Lambda function" time="0.017">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode S3ObjectVersion is hotswappable" name="&quot;fall-back&quot; mode S3ObjectVersion is hotswappable" time="0.014">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode calls the updateLambdaConfiguration() API when it receives difference in Environment field of a Lambda function" name="&quot;fall-back&quot; mode calls the updateLambdaConfiguration() API when it receives difference in Environment field of a Lambda function" time="0.013">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode will not perform a hotswap deployment if it cannot find a Ref target (outside the function&apos;s name)" name="&quot;fall-back&quot; mode will not perform a hotswap deployment if it cannot find a Ref target (outside the function&apos;s name)" time="0.053">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode does not call the updateLambdaCode() API when a resource with type that is not AWS::Lambda::Function but has the same properties is changed" name="&quot;fall-back&quot; mode does not call the updateLambdaCode() API when a resource with type that is not AWS::Lambda::Function but has the same properties is changed" time="0.038">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode calls getFunction() after function code is updated on a VPC function with delay 5" name="&quot;fall-back&quot; mode calls getFunction() after function code is updated on a VPC function with delay 5" time="0.012">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode calls the updateLambdaConfiguration() API when it receives difference in Description field of a Lambda function" name="&quot;fall-back&quot; mode calls the updateLambdaConfiguration() API when it receives difference in Description field of a Lambda function" time="0.013">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode does not call the updateLambdaCode() API when it receives a change that is not a code difference in a Lambda function" name="&quot;fall-back&quot; mode does not call the updateLambdaCode() API when it receives a change that is not a code difference in a Lambda function" time="0.016">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode when it receives a non-hotswappable change that includes a code difference in a Lambda function, it does not call the updateLambdaCode()
        API in CLASSIC mode but does in HOTSWAP_ONLY mode" name="&quot;fall-back&quot; mode when it receives a non-hotswappable change that includes a code difference in a Lambda function, it does not call the updateLambdaCode()
        API in CLASSIC mode but does in HOTSWAP_ONLY mode" time="0.01">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode calls waiter after function code is updated with delay 1" name="&quot;fall-back&quot; mode calls waiter after function code is updated with delay 1" time="0.01">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode Lambda hotswap works properly with changes of environment variables and description with tokens" name="&quot;fall-back&quot; mode Lambda hotswap works properly with changes of environment variables and description with tokens" time="0.015">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode calls the updateLambdaCode() API when it receives a code difference in a Lambda function with no name" name="&quot;fall-back&quot; mode calls the updateLambdaCode() API when it receives a code difference in a Lambda function with no name" time="0.014">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode correctly falls back to taking the function&apos;s name from the current stack if it can&apos;t evaluate it in the template" name="&quot;fall-back&quot; mode correctly falls back to taking the function&apos;s name from the current stack if it can&apos;t evaluate it in the template" time="0.014">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode returns undefined when a new Lambda function is added to the Stack" name="&quot;fall-back&quot; mode returns undefined when a new Lambda function is added to the Stack" time="0.045">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode will not perform a hotswap deployment if it doesn&apos;t know how to handle a specific attribute (outside the function&apos;s name)" name="&quot;fall-back&quot; mode will not perform a hotswap deployment if it doesn&apos;t know how to handle a specific attribute (outside the function&apos;s name)" time="0.013">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode calls waiter after function code is updated with delay 1" name="&quot;hotswap-only&quot; mode calls waiter after function code is updated with delay 1" time="0.016">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode when it receives a non-hotswappable change that includes a code difference in a Lambda function, it does not call the updateLambdaCode()
        API in CLASSIC mode but does in HOTSWAP_ONLY mode" name="&quot;hotswap-only&quot; mode when it receives a non-hotswappable change that includes a code difference in a Lambda function, it does not call the updateLambdaCode()
        API in CLASSIC mode but does in HOTSWAP_ONLY mode" time="0.013">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode calls the updateLambdaCode() API when it receives only a code difference in a Lambda function" name="&quot;hotswap-only&quot; mode calls the updateLambdaCode() API when it receives only a code difference in a Lambda function" time="0.014">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode calls the updateLambdaConfiguration() API when it receives difference in Environment field of a Lambda function" name="&quot;hotswap-only&quot; mode calls the updateLambdaConfiguration() API when it receives difference in Environment field of a Lambda function" time="0.01">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode calls the updateLambdaCode() API when it receives a code difference in a Lambda function with no name" name="&quot;hotswap-only&quot; mode calls the updateLambdaCode() API when it receives a code difference in a Lambda function with no name" time="0.015">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode will not perform a hotswap deployment if it doesn&apos;t know how to handle a specific attribute (outside the function&apos;s name)" name="&quot;hotswap-only&quot; mode will not perform a hotswap deployment if it doesn&apos;t know how to handle a specific attribute (outside the function&apos;s name)" time="0.013">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode calls both updateLambdaCode() and updateLambdaConfiguration() API when it receives both code and configuration change" name="&quot;hotswap-only&quot; mode calls both updateLambdaCode() and updateLambdaConfiguration() API when it receives both code and configuration change" time="0.013">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode Lambda hotswap works properly with changes of environment variables and description with tokens" name="&quot;hotswap-only&quot; mode Lambda hotswap works properly with changes of environment variables and description with tokens" time="0.012">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode S3ObjectVersion is hotswappable" name="&quot;hotswap-only&quot; mode S3ObjectVersion is hotswappable" time="0.009">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode correctly falls back to taking the function&apos;s name from the current stack if it can&apos;t evaluate it in the template" name="&quot;hotswap-only&quot; mode correctly falls back to taking the function&apos;s name from the current stack if it can&apos;t evaluate it in the template" time="0.014">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode does not call the updateLambdaCode() API when a resource with type that is not AWS::Lambda::Function but has the same properties is changed" name="&quot;hotswap-only&quot; mode does not call the updateLambdaCode() API when a resource with type that is not AWS::Lambda::Function but has the same properties is changed" time="0.02">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode correctly evaluates the function&apos;s name when it references a different resource from the template" name="&quot;hotswap-only&quot; mode correctly evaluates the function&apos;s name when it references a different resource from the template" time="0.097">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode returns undefined when a new Lambda function is added to the Stack" name="&quot;hotswap-only&quot; mode returns undefined when a new Lambda function is added to the Stack" time="0.01">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode will not perform a hotswap deployment if it cannot find a Ref target (outside the function&apos;s name)" name="&quot;hotswap-only&quot; mode will not perform a hotswap deployment if it cannot find a Ref target (outside the function&apos;s name)" time="0.01">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode calls the updateLambdaConfiguration() API when it receives difference in Description field of a Lambda function" name="&quot;hotswap-only&quot; mode calls the updateLambdaConfiguration() API when it receives difference in Description field of a Lambda function" time="0.013">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode calls getFunction() after function code is updated on a VPC function with delay 5" name="&quot;hotswap-only&quot; mode calls getFunction() after function code is updated on a VPC function with delay 5" time="0.019">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode calls waiter after function code is updated and VpcId is empty string with delay 1" name="&quot;hotswap-only&quot; mode calls waiter after function code is updated and VpcId is empty string with delay 1" time="0.016">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode does not call the updateLambdaCode() API when it receives a change that is not a code difference in a Lambda function" name="&quot;hotswap-only&quot; mode does not call the updateLambdaCode() API when it receives a change that is not a code difference in a Lambda function" time="0.012">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="1" timestamp="2025-02-18T18:40:55" time="2.128" tests="13">
    <testcase classname=" application set in --app as `*.js` always uses handler on windows" name=" application set in --app as `*.js` always uses handler on windows" time="0.022">
    </testcase>
    <testcase classname=" cli throws when manifest version &gt; schema version" name=" cli throws when manifest version &gt; schema version" time="0.463">
    </testcase>
    <testcase classname=" cli does not throw when manifest version = schema version" name=" cli does not throw when manifest version = schema version" time="0.046">
    </testcase>
    <testcase classname=" the application set in --app is executed" name=" the application set in --app is executed" time="0.027">
    </testcase>
    <testcase classname=" the application set in --app is executed with arguments" name=" the application set in --app is executed with arguments" time="0.067">
    </testcase>
    <testcase classname=" cli throws when the `build` script fails" name=" cli throws when the `build` script fails" time="0.017">
    </testcase>
    <testcase classname=" cli releases the outdir lock when execProgram throws" name=" cli releases the outdir lock when execProgram throws" time="0.025">
    </testcase>
    <testcase classname=" bypasses synth when app points to a cloud assembly" name=" bypasses synth when app points to a cloud assembly" time="0.018">
    </testcase>
    <testcase classname=" validates --app key is present" name=" validates --app key is present" time="0.004">
    </testcase>
    <testcase classname=" cli does not throw when manifest version &lt; schema version" name=" cli does not throw when manifest version &lt; schema version" time="0">
      <skipped/>
    </testcase>
    <testcase classname=" the application set in --app is executed as-is if it contains a filename that does not exist" name=" the application set in --app is executed as-is if it contains a filename that does not exist" time="0.014">
    </testcase>
    <testcase classname=" cli does not throw when the `build` script succeeds" name=" cli does not throw when the `build` script succeeds" time="0.014">
    </testcase>
    <testcase classname=" application set in --app is `*.js` and executable" name=" application set in --app is `*.js` and executable" time="0.012">
    </testcase>
  </testsuite>
  <testsuite name="&quot;fall-back&quot; mode" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:40:55" time="1.539" tests="6">
    <testcase classname="&quot;fall-back&quot; mode throws error in case of timeout" name="&quot;fall-back&quot; mode throws error in case of timeout" time="0.543">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode calls the waiter with a delay of 5" name="&quot;fall-back&quot; mode calls the waiter with a delay of 5" time="0.023">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode calls the updateLambdaCode() API when it receives only a code difference in a Lambda function" name="&quot;fall-back&quot; mode calls the updateLambdaCode() API when it receives only a code difference in a Lambda function" time="0.012">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode calls the updateLambdaCode() API when it receives only a code difference in a Lambda function" name="&quot;hotswap-only&quot; mode calls the updateLambdaCode() API when it receives only a code difference in a Lambda function" time="0.009">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode throws error in case of timeout" name="&quot;hotswap-only&quot; mode throws error in case of timeout" time="0.012">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode calls the waiter with a delay of 5" name="&quot;hotswap-only&quot; mode calls the waiter with a delay of 5" time="0.009">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:40:54" time="3.18" tests="2">
    <testcase classname=" process events" name=" process events" time="1.004">
    </testcase>
    <testcase classname=" process truncated events" name=" process truncated events" time="1.003">
    </testcase>
  </testsuite>
  <testsuite name="cdk bootstrap" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:40:56" time="1.452" tests="2">
    <testcase classname="cdk bootstrap will bootstrap the a provided environment" name="cdk bootstrap will bootstrap the a provided environment" time="0.158">
    </testcase>
    <testcase classname="cdk bootstrap --show-template prints the default bootstrap template" name="cdk bootstrap --show-template prints the default bootstrap template" time="0.066">
    </testcase>
  </testsuite>
  <testsuite name="security group context provider plugin" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:40:57" time="0.935" tests="12">
    <testcase classname="security group context provider plugin errors when securityGroupId and securityGroupName are specified both" name="security group context provider plugin errors when securityGroupId and securityGroupName are specified both" time="0.012">
    </testcase>
    <testcase classname="security group context provider plugin errors when no matches are found" name="security group context provider plugin errors when no matches are found" time="0.008">
    </testcase>
    <testcase classname="security group context provider plugin looks up by security group name and vpc id" name="security group context provider plugin looks up by security group name and vpc id" time="0.004">
    </testcase>
    <testcase classname="security group context provider plugin errors when more than one security group is found" name="security group context provider plugin errors when more than one security group is found" time="0.005">
    </testcase>
    <testcase classname="security group context provider plugin identifies allTrafficEgress from SecurityGroup permissions" name="security group context provider plugin identifies allTrafficEgress from SecurityGroup permissions" time="0.01">
    </testcase>
    <testcase classname="security group context provider plugin identifies lacking allTrafficEgress from SecurityGroup permissions" name="security group context provider plugin identifies lacking allTrafficEgress from SecurityGroup permissions" time="0.003">
    </testcase>
    <testcase classname="security group context provider plugin looks up by security group name" name="security group context provider plugin looks up by security group name" time="0.003">
    </testcase>
    <testcase classname="security group context provider plugin looks up by security group id and vpc id" name="security group context provider plugin looks up by security group id and vpc id" time="0.004">
    </testcase>
    <testcase classname="security group context provider plugin looks up by security group id" name="security group context provider plugin looks up by security group id" time="0.004">
    </testcase>
    <testcase classname="security group context provider plugin detects non all-outbound egress" name="security group context provider plugin detects non all-outbound egress" time="0.006">
    </testcase>
    <testcase classname="security group context provider plugin identifies allTrafficEgress from SecurityGroup permissions when combined" name="security group context provider plugin identifies allTrafficEgress from SecurityGroup permissions when combined" time="0.004">
    </testcase>
    <testcase classname="security group context provider plugin errors when neither securityGroupId nor securityGroupName are specified" name="security group context provider plugin errors when neither securityGroupId nor securityGroupName are specified" time="0.005">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:40:57" time="2.381" tests="1">
    <testcase classname=" parallelPromises" name=" parallelPromises" time="1.364">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:40:57" time="1.889" tests="12">
    <testcase classname=" asks human for resource identifiers" name=" asks human for resource identifiers" time="0.389">
    </testcase>
    <testcase classname=" by default, its an error if there are non-addition changes in the template" name=" by default, its an error if there are non-addition changes in the template" time="0.023">
    </testcase>
    <testcase classname=" take compound identifiers from the template if found" name=" take compound identifiers from the template if found" time="0.021">
    </testcase>
    <testcase classname=" only ask user for one identifier if multiple possible ones are possible" name=" only ask user for one identifier if multiple possible ones are possible" time="0.039">
    </testcase>
    <testcase classname=" asks human to confirm automic import if identifier is in template" name=" asks human to confirm automic import if identifier is in template" time="0.008">
    </testcase>
    <testcase classname=" ask user for compound identifiers if not found" name=" ask user for compound identifiers if not found" time="0.025">
    </testcase>
    <testcase classname=" discovers importable resources" name=" discovers importable resources" time="0.005">
    </testcase>
    <testcase classname=" only use one identifier if multiple are in template" name=" only use one identifier if multiple are in template" time="0.025">
    </testcase>
    <testcase classname=" do not ask for second part of compound identifier if the user skips the first" name=" do not ask for second part of compound identifier if the user skips the first" time="0.046">
    </testcase>
    <testcase classname=" ask identifier if the value in the template is a CFN intrinsic" name=" ask identifier if the value in the template is a CFN intrinsic" time="0.071">
    </testcase>
    <testcase classname=" importing resources from migrate strips cdk metadata and outputs" name=" importing resources from migrate strips cdk metadata and outputs" time="0.01">
    </testcase>
    <testcase classname=" asks human to confirm automic import if identifier is in template" name=" asks human to confirm automic import if identifier is in template" time="0.008">
    </testcase>
  </testsuite>
  <testsuite name="WorkGraph" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:40:57" time="2.647" tests="52">
    <testcase classname="WorkGraph Failure - Concurrency: 1 - A -&gt; b (asset publish error)" name="WorkGraph Failure - Concurrency: 1 - A -&gt; b (asset publish error)" time="0.023">
    </testcase>
    <testcase classname="WorkGraph Success - Concurrency: 1 - A -&gt; B, A not selected" name="WorkGraph Success - Concurrency: 1 - A -&gt; B, A not selected" time="0.002">
    </testcase>
    <testcase classname="WorkGraph Success - Concurrency: 1 - A" name="WorkGraph Success - Concurrency: 1 - A" time="0.003">
    </testcase>
    <testcase classname="WorkGraph Failure - Concurrency: 1 - A (error), B" name="WorkGraph Failure - Concurrency: 1 - A (error), B" time="0.003">
    </testcase>
    <testcase classname="WorkGraph Success - Concurrency: 2 - A -&gt; a" name="WorkGraph Success - Concurrency: 2 - A -&gt; a" time="0.006">
    </testcase>
    <testcase classname="WorkGraph Success - Concurrency: 2 - A (slow) -&gt; B, C -&gt; D" name="WorkGraph Success - Concurrency: 2 - A (slow) -&gt; B, C -&gt; D" time="0.206">
    </testcase>
    <testcase classname="WorkGraph Success - Concurrency: 2 - A, B -&gt; b -&gt; A" name="WorkGraph Success - Concurrency: 2 - A, B -&gt; b -&gt; A" time="0.007">
    </testcase>
    <testcase classname="WorkGraph Success - Concurrency: 1 - No Stacks" name="WorkGraph Success - Concurrency: 1 - No Stacks" time="0.001">
    </testcase>
    <testcase classname="WorkGraph Success - Concurrency: 2 - A, B" name="WorkGraph Success - Concurrency: 2 - A, B" time="0.201">
    </testcase>
    <testcase classname="WorkGraph Failure - Concurrency: 2 - A -&gt; b (asset publish error), C" name="WorkGraph Failure - Concurrency: 2 - A -&gt; b (asset publish error), C" time="0.003">
    </testcase>
    <testcase classname="WorkGraph Success - Concurrency: 2 - A -&gt; [a, B]" name="WorkGraph Success - Concurrency: 2 - A -&gt; [a, B]" time="0.202">
    </testcase>
    <testcase classname="WorkGraph Success - Concurrency: 1 - [unsorted] A -&gt; B" name="WorkGraph Success - Concurrency: 1 - [unsorted] A -&gt; B" time="0.003">
    </testcase>
    <testcase classname="WorkGraph Failure - Graph Circular Dependencies - A -&gt; B, B -&gt; A" name="WorkGraph Failure - Graph Circular Dependencies - A -&gt; B, B -&gt; A" time="0.003">
    </testcase>
    <testcase classname="WorkGraph Failure - Concurrency: 2 - A (error), B" name="WorkGraph Failure - Concurrency: 2 - A (error), B" time="0.003">
    </testcase>
    <testcase classname="WorkGraph Success - Concurrency: 1 - A -&gt; B -&gt; C" name="WorkGraph Success - Concurrency: 1 - A -&gt; B -&gt; C" time="0.005">
    </testcase>
    <testcase classname="WorkGraph Failure - Graph Circular Dependencies - A -&gt; A" name="WorkGraph Failure - Graph Circular Dependencies - A -&gt; A" time="0.001">
    </testcase>
    <testcase classname="WorkGraph Success - Concurrency: 2 - A, B" name="WorkGraph Success - Concurrency: 2 - A, B" time="0.002">
    </testcase>
    <testcase classname="WorkGraph Failure - Concurrency: 2 - A (error) -&gt; B, C -&gt; D" name="WorkGraph Failure - Concurrency: 2 - A (error) -&gt; B, C -&gt; D" time="0.002">
    </testcase>
    <testcase classname="WorkGraph Failure - Concurrency: 2 - [unsorted] A (error) -&gt; B" name="WorkGraph Failure - Concurrency: 2 - [unsorted] A (error) -&gt; B" time="0.001">
    </testcase>
    <testcase classname="WorkGraph Success - Concurrency: 2 - A -&gt; B, A -&gt; C" name="WorkGraph Success - Concurrency: 2 - A -&gt; B, A -&gt; C" time="0.004">
    </testcase>
    <testcase classname="WorkGraph Success - Concurrency: 1 - A, B" name="WorkGraph Success - Concurrency: 1 - A, B" time="0.004">
    </testcase>
    <testcase classname="WorkGraph Failure - Concurrency: 1 - A -&gt; B, C (error) -&gt; D" name="WorkGraph Failure - Concurrency: 1 - A -&gt; B, C (error) -&gt; D" time="0.203">
    </testcase>
    <testcase classname="WorkGraph Failure - Concurrency: 1 - A, B (error)" name="WorkGraph Failure - Concurrency: 1 - A, B (error)" time="0.004">
    </testcase>
    <testcase classname="WorkGraph Success - Concurrency: 2 - A -&gt; B" name="WorkGraph Success - Concurrency: 2 - A -&gt; B" time="0.004">
    </testcase>
    <testcase classname="WorkGraph Success - Concurrency: 1 - A -&gt; B" name="WorkGraph Success - Concurrency: 1 - A -&gt; B" time="0.003">
    </testcase>
    <testcase classname="WorkGraph Success - Concurrency: 1 - A -&gt; [a, B]" name="WorkGraph Success - Concurrency: 1 - A -&gt; [a, B]" time="0.406">
    </testcase>
    <testcase classname="WorkGraph Success - Concurrency: 2 - A, B -&gt; [b, c], b -&gt; A" name="WorkGraph Success - Concurrency: 2 - A, B -&gt; [b, c], b -&gt; A" time="0.204">
    </testcase>
    <testcase classname="WorkGraph Failure - Concurrency: 2 - A -&gt; B, C (error) -&gt; D" name="WorkGraph Failure - Concurrency: 2 - A -&gt; B, C (error) -&gt; D" time="0.204">
    </testcase>
    <testcase classname="WorkGraph Success - Concurrency: 2 - No Stacks" name="WorkGraph Success - Concurrency: 2 - No Stacks" time="0">
    </testcase>
    <testcase classname="WorkGraph Success - Concurrency: 2 - A -&gt; B, C -&gt; D" name="WorkGraph Success - Concurrency: 2 - A -&gt; B, C -&gt; D" time="0.005">
    </testcase>
    <testcase classname="WorkGraph Success - Concurrency: 1 - A (slow), B" name="WorkGraph Success - Concurrency: 1 - A (slow), B" time="0.21">
    </testcase>
    <testcase classname="WorkGraph Failure - Concurrency: 1 - A (error) -&gt; B, C -&gt; D" name="WorkGraph Failure - Concurrency: 1 - A (error) -&gt; B, C -&gt; D" time="0.003">
    </testcase>
    <testcase classname="WorkGraph Failure - Concurrency: 1 - A (error) -&gt; B" name="WorkGraph Failure - Concurrency: 1 - A (error) -&gt; B" time="0.005">
    </testcase>
    <testcase classname="WorkGraph Failure - Concurrency: 2 - A -&gt; b (asset build error), C" name="WorkGraph Failure - Concurrency: 2 - A -&gt; b (asset build error), C" time="0.002">
    </testcase>
    <testcase classname="WorkGraph Success - Concurrency: 2 - A -&gt; B -&gt; C" name="WorkGraph Success - Concurrency: 2 - A -&gt; B -&gt; C" time="0.004">
    </testcase>
    <testcase classname="WorkGraph Success - Concurrency: 2 - [unsorted] A -&gt; B" name="WorkGraph Success - Concurrency: 2 - [unsorted] A -&gt; B" time="0.005">
    </testcase>
    <testcase classname="WorkGraph Failure - Concurrency: 1 - A (error)" name="WorkGraph Failure - Concurrency: 1 - A (error)" time="0.002">
    </testcase>
    <testcase classname="WorkGraph Failure - Concurrency: 2 - A (error)" name="WorkGraph Failure - Concurrency: 2 - A (error)" time="0.002">
    </testcase>
    <testcase classname="WorkGraph Success - Concurrency: 1 - A -&gt; a, B -&gt; b" name="WorkGraph Success - Concurrency: 1 - A -&gt; a, B -&gt; b" time="0.032">
    </testcase>
    <testcase classname="WorkGraph Success - Concurrency: 2 - A -&gt; a, B -&gt; b" name="WorkGraph Success - Concurrency: 2 - A -&gt; a, B -&gt; b" time="0.005">
    </testcase>
    <testcase classname="WorkGraph Success - Concurrency: 2 - A" name="WorkGraph Success - Concurrency: 2 - A" time="0.003">
    </testcase>
    <testcase classname="WorkGraph Failure - Concurrency: 2 - A, B (error)" name="WorkGraph Failure - Concurrency: 2 - A, B (error)" time="0.003">
    </testcase>
    <testcase classname="WorkGraph Failure - Concurrency: 1 - A -&gt; b (asset build error)" name="WorkGraph Failure - Concurrency: 1 - A -&gt; b (asset build error)" time="0.001">
    </testcase>
    <testcase classname="WorkGraph Failure - Graph Circular Dependencies - A, B -&gt; C, C -&gt; D, D -&gt; B" name="WorkGraph Failure - Graph Circular Dependencies - A, B -&gt; C, C -&gt; D, D -&gt; B" time="0.003">
    </testcase>
    <testcase classname="WorkGraph Success - Concurrency: 1 - A, B -&gt; b -&gt; A" name="WorkGraph Success - Concurrency: 1 - A, B -&gt; b -&gt; A" time="0.006">
    </testcase>
    <testcase classname="WorkGraph Failure - Concurrency: 2 - A (error) -&gt; B" name="WorkGraph Failure - Concurrency: 2 - A (error) -&gt; B" time="0.002">
    </testcase>
    <testcase classname="WorkGraph Success - Concurrency: 1 - A -&gt; a" name="WorkGraph Success - Concurrency: 1 - A -&gt; a" time="0.005">
    </testcase>
    <testcase classname="WorkGraph Success - Concurrency: 1 - A -&gt; B, A -&gt; C" name="WorkGraph Success - Concurrency: 1 - A -&gt; B, A -&gt; C" time="0.004">
    </testcase>
    <testcase classname="WorkGraph can remove unnecessary assets" name="WorkGraph can remove unnecessary assets" time="0.004">
    </testcase>
    <testcase classname="WorkGraph Failure - Concurrency: 1 - [unsorted] A (error) -&gt; B" name="WorkGraph Failure - Concurrency: 1 - [unsorted] A (error) -&gt; B" time="0.001">
    </testcase>
    <testcase classname="WorkGraph Success - Concurrency: 1 - A -&gt; B, C -&gt; D" name="WorkGraph Success - Concurrency: 1 - A -&gt; B, C -&gt; D" time="0.006">
    </testcase>
    <testcase classname="WorkGraph Success - Concurrency: 1 - A (slow) -&gt; B, C -&gt; D" name="WorkGraph Success - Concurrency: 1 - A (slow) -&gt; B, C -&gt; D" time="0.207">
    </testcase>
  </testsuite>
  <testsuite name="&quot;fall-back&quot; mode" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:40:57" time="2.195" tests="24">
    <testcase classname="&quot;fall-back&quot; mode does not call the updateProject() API when a resource with type that is not AWS::CodeBuild::Project but has the same properties is changed" name="&quot;fall-back&quot; mode does not call the updateProject() API when a resource with type that is not AWS::CodeBuild::Project but has the same properties is changed" time="0.377">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode calls the updateProject() API when it receives only a source difference in a CodeBuild project" name="&quot;fall-back&quot; mode calls the updateProject() API when it receives only a source difference in a CodeBuild project" time="0.019">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode when it receives a change that is not Source, SourceVersion, or Environment difference in a CodeBuild project alongside a hotswappable change,
        it does not call the updateProject() API in CLASSIC mode, but it does in HOTSWAP_ONLY mode" name="&quot;fall-back&quot; mode when it receives a change that is not Source, SourceVersion, or Environment difference in a CodeBuild project alongside a hotswappable change,
        it does not call the updateProject() API in CLASSIC mode, but it does in HOTSWAP_ONLY mode" time="0.018">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode calls the updateProject() API when it receives only an environment difference in a CodeBuild project" name="&quot;fall-back&quot; mode calls the updateProject() API when it receives only an environment difference in a CodeBuild project" time="0.012">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode will not perform a hotswap deployment if it doesn&apos;t know how to handle a specific attribute (outside the project&apos;s name)" name="&quot;fall-back&quot; mode will not perform a hotswap deployment if it doesn&apos;t know how to handle a specific attribute (outside the project&apos;s name)" time="0.034">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode correctly falls back to taking the project&apos;s name from the current stack if it can&apos;t evaluate it in the template" name="&quot;fall-back&quot; mode correctly falls back to taking the project&apos;s name from the current stack if it can&apos;t evaluate it in the template" time="0.081">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode returns undefined when a new CodeBuild Project is added to the Stack" name="&quot;fall-back&quot; mode returns undefined when a new CodeBuild Project is added to the Stack" time="0.02">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode will not perform a hotswap deployment if it cannot find a Ref target (outside the project&apos;s name)" name="&quot;fall-back&quot; mode will not perform a hotswap deployment if it cannot find a Ref target (outside the project&apos;s name)" time="0.024">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode calls the updateProject() API when it receives only a source version difference in a CodeBuild project" name="&quot;fall-back&quot; mode calls the updateProject() API when it receives only a source version difference in a CodeBuild project" time="0.012">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode calls the updateProject() API when it receives a difference in a CodeBuild project with no name" name="&quot;fall-back&quot; mode calls the updateProject() API when it receives a difference in a CodeBuild project with no name" time="0.013">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode correctly evaluates the project&apos;s name when it references a different resource from the template" name="&quot;fall-back&quot; mode correctly evaluates the project&apos;s name when it references a different resource from the template" time="0.009">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode does not call the updateProject() API when it receives a change that is not Source, SourceVersion, or Environment difference in a CodeBuild project" name="&quot;fall-back&quot; mode does not call the updateProject() API when it receives a change that is not Source, SourceVersion, or Environment difference in a CodeBuild project" time="0.009">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode will not perform a hotswap deployment if it doesn&apos;t know how to handle a specific attribute (outside the project&apos;s name)" name="&quot;hotswap-only&quot; mode will not perform a hotswap deployment if it doesn&apos;t know how to handle a specific attribute (outside the project&apos;s name)" time="0.052">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode calls the updateProject() API when it receives only an environment difference in a CodeBuild project" name="&quot;hotswap-only&quot; mode calls the updateProject() API when it receives only an environment difference in a CodeBuild project" time="0.037">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode calls the updateProject() API when it receives only a source difference in a CodeBuild project" name="&quot;hotswap-only&quot; mode calls the updateProject() API when it receives only a source difference in a CodeBuild project" time="0.021">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode calls the updateProject() API when it receives only a source version difference in a CodeBuild project" name="&quot;hotswap-only&quot; mode calls the updateProject() API when it receives only a source version difference in a CodeBuild project" time="0.017">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode when it receives a change that is not Source, SourceVersion, or Environment difference in a CodeBuild project alongside a hotswappable change,
        it does not call the updateProject() API in CLASSIC mode, but it does in HOTSWAP_ONLY mode" name="&quot;hotswap-only&quot; mode when it receives a change that is not Source, SourceVersion, or Environment difference in a CodeBuild project alongside a hotswappable change,
        it does not call the updateProject() API in CLASSIC mode, but it does in HOTSWAP_ONLY mode" time="0.025">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode correctly falls back to taking the project&apos;s name from the current stack if it can&apos;t evaluate it in the template" name="&quot;hotswap-only&quot; mode correctly falls back to taking the project&apos;s name from the current stack if it can&apos;t evaluate it in the template" time="0.009">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode correctly evaluates the project&apos;s name when it references a different resource from the template" name="&quot;hotswap-only&quot; mode correctly evaluates the project&apos;s name when it references a different resource from the template" time="0.044">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode returns undefined when a new CodeBuild Project is added to the Stack" name="&quot;hotswap-only&quot; mode returns undefined when a new CodeBuild Project is added to the Stack" time="0.044">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode will not perform a hotswap deployment if it cannot find a Ref target (outside the project&apos;s name)" name="&quot;hotswap-only&quot; mode will not perform a hotswap deployment if it cannot find a Ref target (outside the project&apos;s name)" time="0.015">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode does not call the updateProject() API when a resource with type that is not AWS::CodeBuild::Project but has the same properties is changed" name="&quot;hotswap-only&quot; mode does not call the updateProject() API when a resource with type that is not AWS::CodeBuild::Project but has the same properties is changed" time="0.012">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode calls the updateProject() API when it receives a difference in a CodeBuild project with no name" name="&quot;hotswap-only&quot; mode calls the updateProject() API when it receives a difference in a CodeBuild project with no name" time="0.015">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode does not call the updateProject() API when it receives a change that is not Source, SourceVersion, or Environment difference in a CodeBuild project" name="&quot;hotswap-only&quot; mode does not call the updateProject() API when it receives a change that is not Source, SourceVersion, or Environment difference in a CodeBuild project" time="0.03">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:40:58" time="2.783" tests="13">
    <testcase classname=" Version specified is stored in the TTL file" name=" Version specified is stored in the TTL file" time="0.007">
    </testcase>
    <testcase classname=" Return later version when exists &amp; skip recent re-check" name=" Return later version when exists &amp; skip recent re-check" time="1.357">
    </testcase>
    <testcase classname=" cache file responds correctly when file is not present" name=" cache file responds correctly when file is not present" time="0.001">
    </testcase>
    <testcase classname="version message Includes major upgrade documentation when available" name="version message Includes major upgrade documentation when available" time="0.003">
    </testcase>
    <testcase classname="version message Does not include major upgrade documentation when unavailable" name="version message Does not include major upgrade documentation when unavailable" time="0.002">
    </testcase>
    <testcase classname="version message Prints a message when a new version is available" name="version message Prints a message when a new version is available" time="0.002">
    </testcase>
    <testcase classname=" Return null if version is higher than npm" name=" Return null if version is higher than npm" time="0.001">
    </testcase>
    <testcase classname=" Skip version check if environment variable is set" name=" Skip version check if environment variable is set" time="0.003">
    </testcase>
    <testcase classname=" initialization fails on unwritable directory" name=" initialization fails on unwritable directory" time="0.009">
    </testcase>
    <testcase classname=" Skip version check if cache has not expired" name=" Skip version check if cache has not expired" time="0.001">
    </testcase>
    <testcase classname=" isDeveloperBuild call does not throw an error" name=" isDeveloperBuild call does not throw an error" time="0.001">
    </testcase>
    <testcase classname=" cache file honours the specified TTL" name=" cache file honours the specified TTL" time="1.003">
    </testcase>
    <testcase classname=" No Version specified for storage in the TTL file" name=" No Version specified for storage in the TTL file" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:40:59" time="1.354" tests="10">
    <testcase classname=" throws when multiple VPCs are found" name=" throws when multiple VPCs are found" time="0.039">
    </testcase>
    <testcase classname=" throws when subnet with subnetGroupNameTag not found" name=" throws when subnet with subnetGroupNameTag not found" time="0.008">
    </testcase>
    <testcase classname=" Recognize isolated subnet by route table" name=" Recognize isolated subnet by route table" time="0.007">
    </testcase>
    <testcase classname=" throws when no such VPC is found" name=" throws when no such VPC is found" time="0.005">
    </testcase>
    <testcase classname=" looks up the requested VPC" name=" looks up the requested VPC" time="0.022">
    </testcase>
    <testcase classname=" Recognize private subnet by route table with NAT Gateway" name=" Recognize private subnet by route table with NAT Gateway" time="0.012">
    </testcase>
    <testcase classname=" does not throw when subnet with subnetGroupNameTag is found" name=" does not throw when subnet with subnetGroupNameTag is found" time="0.006">
    </testcase>
    <testcase classname=" uses the VPC main route table when a subnet has no specific association" name=" uses the VPC main route table when a subnet has no specific association" time="0.005">
    </testcase>
    <testcase classname=" Recognize public subnet by route table" name=" Recognize public subnet by route table" time="0.018">
    </testcase>
    <testcase classname=" Recognize private subnet by route table with Transit Gateway" name=" Recognize private subnet by route table with Transit Gateway" time="0.008">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:40:59" time="1.408" tests="4">
    <testcase classname=" get value with private zone and VPC not found" name=" get value with private zone and VPC not found" time="0.02">
    </testcase>
    <testcase classname=" get value without private zone" name=" get value without private zone" time="0.001">
    </testcase>
    <testcase classname=" get value with private zone and VPC found" name=" get value with private zone and VPC found" time="0.002">
    </testcase>
    <testcase classname=" get value with private zone" name=" get value with private zone" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="&quot;fall-back&quot; mode" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:40:59" time="2.472" tests="28">
    <testcase classname="&quot;fall-back&quot; mode calls the updateStateMachine() API when it receives only a definitionString change without Fn::Join in a state machine" name="&quot;fall-back&quot; mode calls the updateStateMachine() API when it receives only a definitionString change without Fn::Join in a state machine" time="0.409">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode returns undefined when a new StateMachine is added to the Stack" name="&quot;fall-back&quot; mode returns undefined when a new StateMachine is added to the Stack" time="0.021">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode calls the updateStateMachine() API when it receives only a definitionString change with Fn::Join in a state machine" name="&quot;fall-back&quot; mode calls the updateStateMachine() API when it receives only a definitionString change with Fn::Join in a state machine" time="0.015">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode can correctly hotswap old style synth changes" name="&quot;fall-back&quot; mode can correctly hotswap old style synth changes" time="0.015">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode will not perform a hotswap deployment if it doesn&apos;t know how to handle a specific attribute (outside the state machines&apos;s name)" name="&quot;fall-back&quot; mode will not perform a hotswap deployment if it doesn&apos;t know how to handle a specific attribute (outside the state machines&apos;s name)" time="0.043">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode does not call the updateStateMachine() API when a resource has a DefinitionString property but is not an AWS::StepFunctions::StateMachine is changed" name="&quot;fall-back&quot; mode does not call the updateStateMachine() API when a resource has a DefinitionString property but is not an AWS::StepFunctions::StateMachine is changed" time="0.042">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode does not call the updateStateMachine() API when it receives a change to a property that is not the definitionString in a state machine
        alongside a hotswappable change in CLASSIC mode but does in HOTSWAP_ONLY mode" name="&quot;fall-back&quot; mode does not call the updateStateMachine() API when it receives a change to a property that is not the definitionString in a state machine
        alongside a hotswappable change in CLASSIC mode but does in HOTSWAP_ONLY mode" time="0.014">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode does not explode if the DependsOn changes" name="&quot;fall-back&quot; mode does not explode if the DependsOn changes" time="0.012">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode knows how to handle attributes of the AWS::Events::EventBus resource" name="&quot;fall-back&quot; mode knows how to handle attributes of the AWS::Events::EventBus resource" time="0.011">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode calls the updateStateMachine() API when it receives a change to the definitionString that uses Attributes in a state machine" name="&quot;fall-back&quot; mode calls the updateStateMachine() API when it receives a change to the definitionString that uses Attributes in a state machine" time="0.03">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode calls the updateStateMachine() API when it receives a change to the definitionString in a state machine that has no name" name="&quot;fall-back&quot; mode calls the updateStateMachine() API when it receives a change to the definitionString in a state machine that has no name" time="0.012">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode knows how to handle attributes of the AWS::KMS::Key resource" name="&quot;fall-back&quot; mode knows how to handle attributes of the AWS::KMS::Key resource" time="0.011">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode will not perform a hotswap deployment if it cannot find a Ref target (outside the state machine&apos;s name)" name="&quot;fall-back&quot; mode will not perform a hotswap deployment if it cannot find a Ref target (outside the state machine&apos;s name)" time="0.011">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode knows how to handle attributes of the AWS::DynamoDB::Table resource" name="&quot;fall-back&quot; mode knows how to handle attributes of the AWS::DynamoDB::Table resource" time="0.013">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode does not call the updateStateMachine() API when a resource has a DefinitionString property but is not an AWS::StepFunctions::StateMachine is changed" name="&quot;hotswap-only&quot; mode does not call the updateStateMachine() API when a resource has a DefinitionString property but is not an AWS::StepFunctions::StateMachine is changed" time="0.009">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode will not perform a hotswap deployment if it doesn&apos;t know how to handle a specific attribute (outside the state machines&apos;s name)" name="&quot;hotswap-only&quot; mode will not perform a hotswap deployment if it doesn&apos;t know how to handle a specific attribute (outside the state machines&apos;s name)" time="0.016">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode will not perform a hotswap deployment if it cannot find a Ref target (outside the state machine&apos;s name)" name="&quot;hotswap-only&quot; mode will not perform a hotswap deployment if it cannot find a Ref target (outside the state machine&apos;s name)" time="0.011">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode knows how to handle attributes of the AWS::DynamoDB::Table resource" name="&quot;hotswap-only&quot; mode knows how to handle attributes of the AWS::DynamoDB::Table resource" time="0.011">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode knows how to handle attributes of the AWS::Events::EventBus resource" name="&quot;hotswap-only&quot; mode knows how to handle attributes of the AWS::Events::EventBus resource" time="0.01">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode calls the updateStateMachine() API when it receives a change to the definitionString that uses Attributes in a state machine" name="&quot;hotswap-only&quot; mode calls the updateStateMachine() API when it receives a change to the definitionString that uses Attributes in a state machine" time="0.01">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode knows how to handle attributes of the AWS::KMS::Key resource" name="&quot;hotswap-only&quot; mode knows how to handle attributes of the AWS::KMS::Key resource" time="0.014">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode calls the updateStateMachine() API when it receives a change to the definitionString in a state machine that has no name" name="&quot;hotswap-only&quot; mode calls the updateStateMachine() API when it receives a change to the definitionString in a state machine that has no name" time="0.011">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode calls the updateStateMachine() API when it receives only a definitionString change with Fn::Join in a state machine" name="&quot;hotswap-only&quot; mode calls the updateStateMachine() API when it receives only a definitionString change with Fn::Join in a state machine" time="0.011">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode calls the updateStateMachine() API when it receives only a definitionString change without Fn::Join in a state machine" name="&quot;hotswap-only&quot; mode calls the updateStateMachine() API when it receives only a definitionString change without Fn::Join in a state machine" time="0.015">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode returns undefined when a new StateMachine is added to the Stack" name="&quot;hotswap-only&quot; mode returns undefined when a new StateMachine is added to the Stack" time="0.017">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode does not call the updateStateMachine() API when it receives a change to a property that is not the definitionString in a state machine
        alongside a hotswappable change in CLASSIC mode but does in HOTSWAP_ONLY mode" name="&quot;hotswap-only&quot; mode does not call the updateStateMachine() API when it receives a change to a property that is not the definitionString in a state machine
        alongside a hotswappable change in CLASSIC mode but does in HOTSWAP_ONLY mode" time="0.023">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode does not explode if the DependsOn changes" name="&quot;hotswap-only&quot; mode does not explode if the DependsOn changes" time="0.013">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode can correctly hotswap old style synth changes" name="&quot;hotswap-only&quot; mode can correctly hotswap old style synth changes" time="0.016">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:01" time="1.31" tests="3">
    <testcase classname=" fails if lookups are disabled and missing context is synthesized" name=" fails if lookups are disabled and missing context is synthesized" time="0.033">
    </testcase>
    <testcase classname="AWS::CDK::Metadata is not generated for new frameworks" name="AWS::CDK::Metadata is not generated for new frameworks" time="0.011">
    </testcase>
    <testcase classname=" stop executing if context providers are not making progress" name=" stop executing if context providers are not making progress" time="0.018">
    </testcase>
  </testsuite>
  <testsuite name="&quot;fall-back&quot; mode" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:00" time="2.286" tests="20">
    <testcase classname="&quot;fall-back&quot; mode does not call the invokeLambda() api if the updated Policy has no Roles in CLASSIC mode but does in HOTSWAP_ONLY mode" name="&quot;fall-back&quot; mode does not call the invokeLambda() api if the updated Policy has no Roles in CLASSIC mode but does in HOTSWAP_ONLY mode" time="0.478">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode throws an error when the serviceToken fails evaluation in the template" name="&quot;fall-back&quot; mode throws an error when the serviceToken fails evaluation in the template" time="0.041">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode calls the lambdaInvoke() API when it receives only an asset difference in an S3 bucket deployment and evaluates CFN expressions in S3 Deployment Properties" name="&quot;fall-back&quot; mode calls the lambdaInvoke() API when it receives only an asset difference in an S3 bucket deployment and evaluates CFN expressions in S3 Deployment Properties" time="0.016">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode old-style synthesis calls the lambdaInvoke() API when it receives an asset difference in an S3 bucket deployment and an IAM Policy difference using old-style synthesis" name="&quot;fall-back&quot; mode old-style synthesis calls the lambdaInvoke() API when it receives an asset difference in an S3 bucket deployment and an IAM Policy difference using old-style synthesis" time="0.018">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode old-style synthesis calls the lambdaInvoke() API when it receives an asset difference in two S3 bucket deployments and IAM Policy differences using old-style synthesis" name="&quot;fall-back&quot; mode old-style synthesis calls the lambdaInvoke() API when it receives an asset difference in two S3 bucket deployments and IAM Policy differences using old-style synthesis" time="0.015">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode old-style synthesis does not call the lambdaInvoke() API when the difference in the S3 deployment is referred to in one IAM policy change but not another
          in CLASSIC mode but does in HOTSWAP_ONLY" name="&quot;fall-back&quot; mode old-style synthesis does not call the lambdaInvoke() API when the difference in the S3 deployment is referred to in one IAM policy change but not another
          in CLASSIC mode but does in HOTSWAP_ONLY" time="0.011">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode old-style synthesis does not call the lambdaInvoke() API when a policy is referenced by a resource that is not an S3 deployment
          in CLASSIC mode but does in HOTSWAP_ONLY mode" name="&quot;fall-back&quot; mode old-style synthesis does not call the lambdaInvoke() API when a policy is referenced by a resource that is not an S3 deployment
          in CLASSIC mode but does in HOTSWAP_ONLY mode" time="0.013">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode old-style synthesis does not call the lambdaInvoke() API when it receives an asset difference in an S3 bucket deployment that references two different policies
          in CLASSIC mode but does in HOTSWAP_ONLY mode" name="&quot;fall-back&quot; mode old-style synthesis does not call the lambdaInvoke() API when it receives an asset difference in an S3 bucket deployment that references two different policies
          in CLASSIC mode but does in HOTSWAP_ONLY mode" time="0.01">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode old-style synthesis does not call the lambdaInvoke() API when the lambda that references the role is referred to by something other than an S3 deployment
          in CLASSIC mode but does in HOTSWAP_ONLY mode" name="&quot;fall-back&quot; mode old-style synthesis does not call the lambdaInvoke() API when the lambda that references the role is referred to by something other than an S3 deployment
          in CLASSIC mode but does in HOTSWAP_ONLY mode" time="0.009">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode does not call the invoke() API when a resource with type that is not Custom::CDKBucketDeployment but has the same properties is changed" name="&quot;fall-back&quot; mode does not call the invoke() API when a resource with type that is not Custom::CDKBucketDeployment but has the same properties is changed" time="0.009">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode throws an error when the serviceToken fails evaluation in the template" name="&quot;hotswap-only&quot; mode throws an error when the serviceToken fails evaluation in the template" time="0.01">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode old-style synthesis calls the lambdaInvoke() API when it receives an asset difference in an S3 bucket deployment and an IAM Policy difference using old-style synthesis" name="&quot;hotswap-only&quot; mode old-style synthesis calls the lambdaInvoke() API when it receives an asset difference in an S3 bucket deployment and an IAM Policy difference using old-style synthesis" time="0.012">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode old-style synthesis does not call the lambdaInvoke() API when a policy is referenced by a resource that is not an S3 deployment
          in CLASSIC mode but does in HOTSWAP_ONLY mode" name="&quot;hotswap-only&quot; mode old-style synthesis does not call the lambdaInvoke() API when a policy is referenced by a resource that is not an S3 deployment
          in CLASSIC mode but does in HOTSWAP_ONLY mode" time="0.013">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode old-style synthesis does not call the lambdaInvoke() API when it receives an asset difference in an S3 bucket deployment that references two different policies
          in CLASSIC mode but does in HOTSWAP_ONLY mode" name="&quot;hotswap-only&quot; mode old-style synthesis does not call the lambdaInvoke() API when it receives an asset difference in an S3 bucket deployment that references two different policies
          in CLASSIC mode but does in HOTSWAP_ONLY mode" time="0.017">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode old-style synthesis does not call the lambdaInvoke() API when the difference in the S3 deployment is referred to in one IAM policy change but not another
          in CLASSIC mode but does in HOTSWAP_ONLY" name="&quot;hotswap-only&quot; mode old-style synthesis does not call the lambdaInvoke() API when the difference in the S3 deployment is referred to in one IAM policy change but not another
          in CLASSIC mode but does in HOTSWAP_ONLY" time="0.014">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode old-style synthesis does not call the lambdaInvoke() API when the lambda that references the role is referred to by something other than an S3 deployment
          in CLASSIC mode but does in HOTSWAP_ONLY mode" name="&quot;hotswap-only&quot; mode old-style synthesis does not call the lambdaInvoke() API when the lambda that references the role is referred to by something other than an S3 deployment
          in CLASSIC mode but does in HOTSWAP_ONLY mode" time="0.017">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode old-style synthesis calls the lambdaInvoke() API when it receives an asset difference in two S3 bucket deployments and IAM Policy differences using old-style synthesis" name="&quot;hotswap-only&quot; mode old-style synthesis calls the lambdaInvoke() API when it receives an asset difference in two S3 bucket deployments and IAM Policy differences using old-style synthesis" time="0.027">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode does not call the invokeLambda() api if the updated Policy has no Roles in CLASSIC mode but does in HOTSWAP_ONLY mode" name="&quot;hotswap-only&quot; mode does not call the invokeLambda() api if the updated Policy has no Roles in CLASSIC mode but does in HOTSWAP_ONLY mode" time="0.022">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode does not call the invoke() API when a resource with type that is not Custom::CDKBucketDeployment but has the same properties is changed" name="&quot;hotswap-only&quot; mode does not call the invoke() API when a resource with type that is not Custom::CDKBucketDeployment but has the same properties is changed" time="0.017">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode calls the lambdaInvoke() API when it receives only an asset difference in an S3 bucket deployment and evaluates CFN expressions in S3 Deployment Properties" name="&quot;hotswap-only&quot; mode calls the lambdaInvoke() API when it receives only an asset difference in an S3 bucket deployment and evaluates CFN expressions in S3 Deployment Properties" time="0.021">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:01" time="2.071" tests="51">
    <testcase classname=" use S3 url for stack deployment if present in Stack Artifact" name=" use S3 url for stack deployment if present in Stack Artifact" time="0.023">
    </testcase>
    <testcase classname=" rollback still defaults to enabled even if &apos;hotswap&apos; is enabled" name=" rollback still defaults to enabled even if &apos;hotswap&apos; is enabled" time="0.017">
    </testcase>
    <testcase classname=" deploy is skipped if template and tags did not change" name=" deploy is skipped if template and tags did not change" time="0.005">
    </testcase>
    <testcase classname=" deploy is skipped if notificationArns are the same" name=" deploy is skipped if notificationArns are the same" time="0.006">
    </testcase>
    <testcase classname=" does not call tryHotswapDeployment() if &apos;hotswap&apos; is false" name=" does not call tryHotswapDeployment() if &apos;hotswap&apos; is false" time="0.017">
    </testcase>
    <testcase classname=" deploy not skipped if template changed" name=" deploy not skipped if template changed" time="0.009">
    </testcase>
    <testcase classname=" assertIsSuccessfulDeployStackResult does what it says" name=" assertIsSuccessfulDeployStackResult does what it says" time="0.027">
    </testcase>
    <testcase classname=" call CreateStack when method=direct and the stack doesnt exist yet" name=" call CreateStack when method=direct and the stack doesnt exist yet" time="0.007">
    </testcase>
    <testcase classname=" changeset is created when stack exists in REVIEW_IN_PROGRESS status" name=" changeset is created when stack exists in REVIEW_IN_PROGRESS status" time="0.008">
    </testcase>
    <testcase classname=" deploy is not skipped if parameters are different" name=" deploy is not skipped if parameters are different" time="0.016">
    </testcase>
    <testcase classname=" reuse previous parameters if requested" name=" reuse previous parameters if requested" time="0.006">
    </testcase>
    <testcase classname=" updateTerminationProtection not called when termination protection is undefined" name=" updateTerminationProtection not called when termination protection is undefined" time="0.004">
    </testcase>
    <testcase classname=" not executed and no error if --no-execute is given" name=" not executed and no error if --no-execute is given" time="0.005">
    </testcase>
    <testcase classname=" deploy not skipped if template did not change and --force is applied" name=" deploy not skipped if template did not change and --force is applied" time="0.006">
    </testcase>
    <testcase classname=" deploy is not skipped if stack is in a _FAILED state" name=" deploy is not skipped if stack is in a _FAILED state" time="0.006">
    </testcase>
    <testcase classname=" method=direct and no updates to be performed" name=" method=direct and no updates to be performed" time="0.008">
    </testcase>
    <testcase classname=" no-rollback and replacement is disadvised: UPDATE_FAILED rollback replacement -&gt; failpaused-need-rollback-first" name=" no-rollback and replacement is disadvised: UPDATE_FAILED rollback replacement -&gt; failpaused-need-rollback-first" time="0.011">
    </testcase>
    <testcase classname=" existing stack in UPDATE_ROLLBACK_COMPLETE state can be updated" name=" existing stack in UPDATE_ROLLBACK_COMPLETE state can be updated" time="0.006">
    </testcase>
    <testcase classname=" deploy not skipped if template did not change but one tag removed" name=" deploy not skipped if template did not change but one tag removed" time="0.006">
    </testcase>
    <testcase classname="ci=true output written to stdout" name="ci=true output written to stdout" time="0.004">
    </testcase>
    <testcase classname=" deploy is skipped if parameters are the same" name=" deploy is skipped if parameters are the same" time="0.005">
    </testcase>
    <testcase classname=" empty change set is not deleted if --no-execute is given" name=" empty change set is not deleted if --no-execute is given" time="0.005">
    </testcase>
    <testcase classname=" empty change set is deleted if --execute is given" name=" empty change set is deleted if --execute is given" time="0.011">
    </testcase>
    <testcase classname=" do not reuse previous parameters if not requested" name=" do not reuse previous parameters if not requested" time="0.005">
    </testcase>
    <testcase classname="import-existing-resources is added to the CreateChangeSetCommandInput" name="import-existing-resources is added to the CreateChangeSetCommandInput" time="0.019">
    </testcase>
    <testcase classname="import-existing-resources is disabled by default" name="import-existing-resources is disabled by default" time="0.016">
    </testcase>
    <testcase classname=" deploy is skipped if template did not change" name=" deploy is skipped if template did not change" time="0.009">
    </testcase>
    <testcase classname=" calls tryHotswapDeployment() if &apos;hotswap&apos; is `HotswapMode.CLASSIC`" name=" calls tryHotswapDeployment() if &apos;hotswap&apos; is `HotswapMode.CLASSIC`" time="0.022">
    </testcase>
    <testcase classname=" calls tryHotswapDeployment() if &apos;hotswap&apos; is `HotswapMode.HOTSWAP_ONLY`" name=" calls tryHotswapDeployment() if &apos;hotswap&apos; is `HotswapMode.HOTSWAP_ONLY`" time="0.047">
    </testcase>
    <testcase classname=" updateTerminationProtection called when termination protection is undefined and stack has termination protection" name=" updateTerminationProtection called when termination protection is undefined and stack has termination protection" time="0.006">
    </testcase>
    <testcase classname=" deployStack reports no change if describeChangeSet returns specific error" name=" deployStack reports no change if describeChangeSet returns specific error" time="0.012">
    </testcase>
    <testcase classname=" correctly passes CFN parameters when hotswapping" name=" correctly passes CFN parameters when hotswapping" time="0.004">
    </testcase>
    <testcase classname=" deploy with termination protection enabled" name=" deploy with termination protection enabled" time="0.005">
    </testcase>
    <testcase classname=" no-rollback and replacement is disadvised: UPDATE_FAILED no-rollback no-replacement -&gt; did-deploy-stack" name=" no-rollback and replacement is disadvised: UPDATE_FAILED no-rollback no-replacement -&gt; did-deploy-stack" time="0.007">
    </testcase>
    <testcase classname=" no-rollback and replacement is disadvised: UPDATE_COMPLETE no-rollback replacement -&gt; replacement-requires-rollback" name=" no-rollback and replacement is disadvised: UPDATE_COMPLETE no-rollback replacement -&gt; replacement-requires-rollback" time="0.005">
    </testcase>
    <testcase classname=" no-rollback and replacement is disadvised: UPDATE_FAILED no-rollback replacement -&gt; failpaused-need-rollback-first" name=" no-rollback and replacement is disadvised: UPDATE_FAILED no-rollback replacement -&gt; failpaused-need-rollback-first" time="0.006">
    </testcase>
    <testcase classname=" correctly passes CFN parameters, ignoring ones with empty values" name=" correctly passes CFN parameters, ignoring ones with empty values" time="0.004">
    </testcase>
    <testcase classname=" use REST API S3 url with substituted placeholders if manifest url starts with s3://" name=" use REST API S3 url with substituted placeholders if manifest url starts with s3://" time="0.017">
    </testcase>
    <testcase classname="disable rollback rollback can be disabled by setting rollback: false" name="disable rollback rollback can be disabled by setting rollback: false" time="0.004">
    </testcase>
    <testcase classname="disable rollback by default, we do not disable rollback (and also do not pass the flag)" name="disable rollback by default, we do not disable rollback (and also do not pass the flag)" time="0.007">
    </testcase>
    <testcase classname=" do deploy executable change set with 0 changes" name=" do deploy executable change set with 0 changes" time="0.004">
    </testcase>
    <testcase classname=" changeset is updated when stack exists in CREATE_COMPLETE status" name=" changeset is updated when stack exists in CREATE_COMPLETE status" time="0.004">
    </testcase>
    <testcase classname=" deploy is not skipped if notificationArns are different" name=" deploy is not skipped if notificationArns are different" time="0.006">
    </testcase>
    <testcase classname=" no-rollback and replacement is disadvised: UPDATE_FAILED rollback no-replacement -&gt; failpaused-need-rollback-first" name=" no-rollback and replacement is disadvised: UPDATE_FAILED rollback no-replacement -&gt; failpaused-need-rollback-first" time="0.008">
    </testcase>
    <testcase classname=" call UpdateStack when method=direct and the stack exists already" name=" call UpdateStack when method=direct and the stack exists already" time="0.004">
    </testcase>
    <testcase classname=" if existing stack failed to create, it is deleted and recreated" name=" if existing stack failed to create, it is deleted and recreated" time="0.01">
    </testcase>
    <testcase classname=" rollback defaults to enabled if &apos;hotswap&apos; is undefined" name=" rollback defaults to enabled if &apos;hotswap&apos; is undefined" time="0.005">
    </testcase>
    <testcase classname=" if existing stack failed to create, it is deleted and recreated even if the template did not change" name=" if existing stack failed to create, it is deleted and recreated even if the template did not change" time="0.007">
    </testcase>
    <testcase classname=" deploy not skipped if template did not change but tags changed" name=" deploy not skipped if template did not change but tags changed" time="0.022">
    </testcase>
    <testcase classname=" throw exception if not enough parameters supplied" name=" throw exception if not enough parameters supplied" time="0.041">
    </testcase>
    <testcase classname=" correctly passes SSM parameters when hotswapping" name=" correctly passes SSM parameters when hotswapping" time="0.013">
    </testcase>
  </testsuite>
  <testsuite name="StackCollection" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:02" time="1.695" tests="20">
    <testcase classname="StackCollection validateMetadata do throw when selecting stack with warnings and we are on strict mode" name="StackCollection validateMetadata do throw when selecting stack with warnings and we are on strict mode" time="0.028">
    </testcase>
    <testcase classname="StackCollection validateMetadata do throw when selecting stack with errors" name="StackCollection validateMetadata do throw when selecting stack with errors" time="0.008">
    </testcase>
    <testcase classname="StackCollection validateMetadata do not throw when selecting stack with warnings" name="StackCollection validateMetadata do not throw when selecting stack with warnings" time="0.005">
    </testcase>
    <testcase classname="StackCollection validateMetadata do not throw when selecting stack with errors but errors are ignored" name="StackCollection validateMetadata do not throw when selecting stack with errors but errors are ignored" time="0.005">
    </testcase>
    <testcase classname="StackCollection validateMetadata do not throw when selecting stack without errors" name="StackCollection validateMetadata do not throw when selecting stack without errors" time="0.004">
    </testcase>
    <testcase classname="StackCollection returns hierarchicalIds" name="StackCollection returns hierarchicalIds" time="0.009">
    </testcase>
    <testcase classname=" select all top level stacks in the presence of nested assemblies" name=" select all top level stacks in the presence of nested assemblies" time="0.036">
    </testcase>
    <testcase classname=" select behavior with nested assemblies: repeat" name=" select behavior with nested assemblies: repeat" time="0.011">
    </testcase>
    <testcase classname=" select behavior with no stacks and default ignore stacks options (false)" name=" select behavior with no stacks and default ignore stacks options (false)" time="0.015">
    </testcase>
    <testcase classname=" select behavior with no stacks and ignore stacks option" name=" select behavior with no stacks and ignore stacks option" time="0.004">
    </testcase>
    <testcase classname=" select behavior with no stacks and no ignore stacks option" name=" select behavior with no stacks and no ignore stacks option" time="0.003">
    </testcase>
    <testcase classname=" select behavior: repeat" name=" select behavior: repeat" time="0.009">
    </testcase>
    <testcase classname=" select behavior: none" name=" select behavior: none" time="0.017">
    </testcase>
    <testcase classname=" select behavior: all" name=" select behavior: all" time="0.024">
    </testcase>
    <testcase classname=" select stacks by glob pattern" name=" select stacks by glob pattern" time="0.014">
    </testcase>
    <testcase classname=" select behavior with nested assemblies: single" name=" select behavior with nested assemblies: single" time="0.016">
    </testcase>
    <testcase classname=" select behavior with nested assemblies: all" name=" select behavior with nested assemblies: all" time="0.017">
    </testcase>
    <testcase classname=" select behavior with nested assemblies: none" name=" select behavior with nested assemblies: none" time="0.014">
    </testcase>
    <testcase classname=" select behavior: single" name=" select behavior: single" time="0.005">
    </testcase>
    <testcase classname=" stack list error contains node paths" name=" stack list error contains node paths" time="0.004">
    </testcase>
  </testsuite>
  <testsuite name="these tests do not depend on the hotswap type" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:01" time="2.679" tests="6">
    <testcase classname="these tests do not depend on the hotswap type throw a CfnEvaluationException when it receives an unsupported function runtime" name="these tests do not depend on the hotswap type throw a CfnEvaluationException when it receives an unsupported function runtime" time="0.713">
    </testcase>
    <testcase classname="these tests do not depend on the hotswap type calls the updateLambdaCode() API when it receives only a code difference in a Lambda function (Inline Python code)" name="these tests do not depend on the hotswap type calls the updateLambdaCode() API when it receives only a code difference in a Lambda function (Inline Python code)" time="0.028">
    </testcase>
    <testcase classname="these tests do not depend on the hotswap type calls the updateLambdaCode() API when it receives only a code difference in a Lambda function (Inline Node.js code)" name="these tests do not depend on the hotswap type calls the updateLambdaCode() API when it receives only a code difference in a Lambda function (Inline Node.js code)" time="0.255">
    </testcase>
    <testcase classname="these tests do not depend on the hotswap type calls the updateLambdaCode() API when it receives only a code difference in a Lambda function (Inline Node.js code)" name="these tests do not depend on the hotswap type calls the updateLambdaCode() API when it receives only a code difference in a Lambda function (Inline Node.js code)" time="0.024">
    </testcase>
    <testcase classname="these tests do not depend on the hotswap type throw a CfnEvaluationException when it receives an unsupported function runtime" name="these tests do not depend on the hotswap type throw a CfnEvaluationException when it receives an unsupported function runtime" time="0.014">
    </testcase>
    <testcase classname="these tests do not depend on the hotswap type calls the updateLambdaCode() API when it receives only a code difference in a Lambda function (Inline Python code)" name="these tests do not depend on the hotswap type calls the updateLambdaCode() API when it receives only a code difference in a Lambda function (Inline Python code)" time="0.016">
    </testcase>
  </testsuite>
  <testsuite name="AwsCliCompatible.region" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:03" time="1.039" tests="16">
    <testcase classname="AwsCliCompatible.region without profile | us-east-1 is priority 3" name="AwsCliCompatible.region without profile | us-east-1 is priority 3" time="0.022">
    </testcase>
    <testcase classname="AwsCliCompatible.region default region can be specified in credentials" name="AwsCliCompatible.region default region can be specified in credentials" time="0.005">
    </testcase>
    <testcase classname="AwsCliCompatible.region without profile | default-region-in-config is priority 2" name="AwsCliCompatible.region without profile | default-region-in-config is priority 2" time="0.012">
    </testcase>
    <testcase classname="AwsCliCompatible.region profile region can be specified in credentials" name="AwsCliCompatible.region profile region can be specified in credentials" time="0.025">
    </testcase>
    <testcase classname="AwsCliCompatible.region with profile | default-region-in-config is priority 4" name="AwsCliCompatible.region with profile | default-region-in-config is priority 4" time="0.015">
    </testcase>
    <testcase classname="AwsCliCompatible.region with profile | profile-region-in-config is priority 2" name="AwsCliCompatible.region with profile | profile-region-in-config is priority 2" time="0.036">
    </testcase>
    <testcase classname="AwsCliCompatible.region default region can be specified in config" name="AwsCliCompatible.region default region can be specified in config" time="0.021">
    </testcase>
    <testcase classname="AwsCliCompatible.region with profile | default-region-in-credentials is priority 3" name="AwsCliCompatible.region with profile | default-region-in-credentials is priority 3" time="0.015">
    </testcase>
    <testcase classname="AwsCliCompatible.region profile region can be specified in config" name="AwsCliCompatible.region profile region can be specified in config" time="0.01">
    </testcase>
    <testcase classname="AwsCliCompatible.region with profile | us-east-1 is priority 5" name="AwsCliCompatible.region with profile | us-east-1 is priority 5" time="0.011">
    </testcase>
    <testcase classname="AwsCliCompatible.region with profile | profile-region-in-credentials is priority 1" name="AwsCliCompatible.region with profile | profile-region-in-credentials is priority 1" time="0.017">
    </testcase>
    <testcase classname="AwsCliCompatible.region without profile | default-region-in-credentials is priority 1" name="AwsCliCompatible.region without profile | default-region-in-credentials is priority 1" time="0.013">
    </testcase>
    <testcase classname="Session token preserves AWS_SESSION_TOKEN if both are defined" name="Session token preserves AWS_SESSION_TOKEN if both are defined" time="0.013">
    </testcase>
    <testcase classname="Session token preserves AWS_SESSION_TOKEN if it is defined" name="Session token preserves AWS_SESSION_TOKEN if it is defined" time="0.003">
    </testcase>
    <testcase classname="Session token does not mess up with session token env variables if they are undefined" name="Session token does not mess up with session token env variables if they are undefined" time="0.006">
    </testcase>
    <testcase classname="Session token assigns AWS_SESSION_TOKEN if it is not defined but AMAZON_SESSION_TOKEN is" name="Session token assigns AWS_SESSION_TOKEN if it is not defined but AMAZON_SESSION_TOKEN is" time="0.051">
    </testcase>
  </testsuite>
  <testsuite name="hotswap properties" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:02" time="2.201" tests="16">
    <testcase classname="hotswap properties should handle all possible hotswap properties" name="hotswap properties should handle all possible hotswap properties" time="0.643">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode if anything besides an ECS Service references the changed TaskDefinition, hotswapping is not possible in CLASSIC mode but is possible in HOTSWAP_ONLY" name="&quot;fall-back&quot; mode if anything besides an ECS Service references the changed TaskDefinition, hotswapping is not possible in CLASSIC mode but is possible in HOTSWAP_ONLY" time="0.045">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode a difference just in a TaskDefinition, without any services using it, is not hotswappable in FALL_BACK mode" name="&quot;fall-back&quot; mode a difference just in a TaskDefinition, without any services using it, is not hotswappable in FALL_BACK mode" time="0.035">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode any other TaskDefinition property change besides ContainerDefinition cannot be hotswapped in CLASSIC mode but does not block HOTSWAP_ONLY mode deployments" name="&quot;fall-back&quot; mode any other TaskDefinition property change besides ContainerDefinition cannot be hotswapped in CLASSIC mode but does not block HOTSWAP_ONLY mode deployments" time="0.015">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode should call registerTaskDefinition with certain properties not lowercased" name="&quot;fall-back&quot; mode should call registerTaskDefinition with certain properties not lowercased" time="0.015">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode should call registerTaskDefinition and updateService for a difference only in the TaskDefinition without a Family property" name="&quot;fall-back&quot; mode should call registerTaskDefinition and updateService for a difference only in the TaskDefinition without a Family property" time="0.016">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode should call registerTaskDefinition and updateService for a difference only in the TaskDefinition with a Family property" name="&quot;fall-back&quot; mode should call registerTaskDefinition and updateService for a difference only in the TaskDefinition with a Family property" time="0.012">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode deleting any other TaskDefinition property besides ContainerDefinition results in a full deployment in CLASSIC mode and a hotswap deployment in HOTSWAP_ONLY mode" name="&quot;fall-back&quot; mode deleting any other TaskDefinition property besides ContainerDefinition results in a full deployment in CLASSIC mode and a hotswap deployment in HOTSWAP_ONLY mode" time="0.01">
    </testcase>
    <testcase classname="hotswap properties should handle all possible hotswap properties" name="hotswap properties should handle all possible hotswap properties" time="0.014">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode any other TaskDefinition property change besides ContainerDefinition cannot be hotswapped in CLASSIC mode but does not block HOTSWAP_ONLY mode deployments" name="&quot;hotswap-only&quot; mode any other TaskDefinition property change besides ContainerDefinition cannot be hotswapped in CLASSIC mode but does not block HOTSWAP_ONLY mode deployments" time="0.018">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode deleting any other TaskDefinition property besides ContainerDefinition results in a full deployment in CLASSIC mode and a hotswap deployment in HOTSWAP_ONLY mode" name="&quot;hotswap-only&quot; mode deleting any other TaskDefinition property besides ContainerDefinition results in a full deployment in CLASSIC mode and a hotswap deployment in HOTSWAP_ONLY mode" time="0.017">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode if anything besides an ECS Service references the changed TaskDefinition, hotswapping is not possible in CLASSIC mode but is possible in HOTSWAP_ONLY" name="&quot;hotswap-only&quot; mode if anything besides an ECS Service references the changed TaskDefinition, hotswapping is not possible in CLASSIC mode but is possible in HOTSWAP_ONLY" time="0.012">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode should call registerTaskDefinition with certain properties not lowercased" name="&quot;hotswap-only&quot; mode should call registerTaskDefinition with certain properties not lowercased" time="0.047">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode a difference just in a TaskDefinition, without any services using it, is not hotswappable in FALL_BACK mode" name="&quot;hotswap-only&quot; mode a difference just in a TaskDefinition, without any services using it, is not hotswappable in FALL_BACK mode" time="0.017">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode should call registerTaskDefinition and updateService for a difference only in the TaskDefinition with a Family property" name="&quot;hotswap-only&quot; mode should call registerTaskDefinition and updateService for a difference only in the TaskDefinition with a Family property" time="0.015">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode should call registerTaskDefinition and updateService for a difference only in the TaskDefinition without a Family property" name="&quot;hotswap-only&quot; mode should call registerTaskDefinition and updateService for a difference only in the TaskDefinition without a Family property" time="0.012">
    </testcase>
  </testsuite>
  <testsuite name="&quot;fall-back&quot; mode" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:02" time="2.534" tests="24">
    <testcase classname="&quot;fall-back&quot; mode can correctly reference Fn::ImportValue in hotswappable changes" name="&quot;fall-back&quot; mode can correctly reference Fn::ImportValue in hotswappable changes" time="0.649">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode A change to only a non-hotswappable resource results in a full deployment for HOTSWAP and a noOp for HOTSWAP_ONLY" name="&quot;fall-back&quot; mode A change to only a non-hotswappable resource results in a full deployment for HOTSWAP and a noOp for HOTSWAP_ONLY" time="0.05">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode deleting a resource and making a hotswappable change results in full deployments for HOTSWAP and a hotswap deployment for HOTSWAP_ONLY" name="&quot;fall-back&quot; mode deleting a resource and making a hotswappable change results in full deployments for HOTSWAP and a hotswap deployment for HOTSWAP_ONLY" time="0.016">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode changes only to CDK::Metadata result in a noOp" name="&quot;fall-back&quot; mode changes only to CDK::Metadata result in a noOp" time="0.012">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode changing the type of a deployed resource always results in a full deployment for HOTSWAP and a noOp for HOTSWAP_ONLY" name="&quot;fall-back&quot; mode changing the type of a deployed resource always results in a full deployment for HOTSWAP and a noOp for HOTSWAP_ONLY" time="0.012">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode can correctly reference AWS::Partition in hotswappable changes" name="&quot;fall-back&quot; mode can correctly reference AWS::Partition in hotswappable changes" time="0.01">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode returns a deployStackResult with noOp=true when it receives an empty set of changes" name="&quot;fall-back&quot; mode returns a deployStackResult with noOp=true when it receives an empty set of changes" time="0.013">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode can correctly reference AWS::URLSuffix in hotswappable changes" name="&quot;fall-back&quot; mode can correctly reference AWS::URLSuffix in hotswappable changes" time="0.02">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode A change to both a hotswappable resource and a non-hotswappable resource results in a full deployment for HOTSWAP and a noOp for HOTSWAP_ONLY" name="&quot;fall-back&quot; mode A change to both a hotswappable resource and a non-hotswappable resource results in a full deployment for HOTSWAP and a noOp for HOTSWAP_ONLY" time="0.012">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode A change to both a hotswappable resource and a stack output results in a full deployment for HOTSWAP and a hotswap deployment for HOTSWAP_ONLY" name="&quot;fall-back&quot; mode A change to both a hotswappable resource and a stack output results in a full deployment for HOTSWAP and a hotswap deployment for HOTSWAP_ONLY" time="0.02">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode resource deletions require full deployments for HOTSWAP and a noOp for HOTSWAP_ONLY" name="&quot;fall-back&quot; mode resource deletions require full deployments for HOTSWAP and a noOp for HOTSWAP_ONLY" time="0.009">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode Multiple CfnEvaluationException will not cause unhandled rejections" name="&quot;fall-back&quot; mode Multiple CfnEvaluationException will not cause unhandled rejections" time="0.067">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode changing the type of a deployed resource always results in a full deployment for HOTSWAP and a noOp for HOTSWAP_ONLY" name="&quot;hotswap-only&quot; mode changing the type of a deployed resource always results in a full deployment for HOTSWAP and a noOp for HOTSWAP_ONLY" time="0.032">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode changes only to CDK::Metadata result in a noOp" name="&quot;hotswap-only&quot; mode changes only to CDK::Metadata result in a noOp" time="0.017">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode A change to only a non-hotswappable resource results in a full deployment for HOTSWAP and a noOp for HOTSWAP_ONLY" name="&quot;hotswap-only&quot; mode A change to only a non-hotswappable resource results in a full deployment for HOTSWAP and a noOp for HOTSWAP_ONLY" time="0.011">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode A change to both a hotswappable resource and a non-hotswappable resource results in a full deployment for HOTSWAP and a noOp for HOTSWAP_ONLY" name="&quot;hotswap-only&quot; mode A change to both a hotswappable resource and a non-hotswappable resource results in a full deployment for HOTSWAP and a noOp for HOTSWAP_ONLY" time="0.009">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode deleting a resource and making a hotswappable change results in full deployments for HOTSWAP and a hotswap deployment for HOTSWAP_ONLY" name="&quot;hotswap-only&quot; mode deleting a resource and making a hotswappable change results in full deployments for HOTSWAP and a hotswap deployment for HOTSWAP_ONLY" time="0.011">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode can correctly reference AWS::Partition in hotswappable changes" name="&quot;hotswap-only&quot; mode can correctly reference AWS::Partition in hotswappable changes" time="0.007">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode resource deletions require full deployments for HOTSWAP and a noOp for HOTSWAP_ONLY" name="&quot;hotswap-only&quot; mode resource deletions require full deployments for HOTSWAP and a noOp for HOTSWAP_ONLY" time="0.016">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode returns a deployStackResult with noOp=true when it receives an empty set of changes" name="&quot;hotswap-only&quot; mode returns a deployStackResult with noOp=true when it receives an empty set of changes" time="0.01">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode can correctly reference AWS::URLSuffix in hotswappable changes" name="&quot;hotswap-only&quot; mode can correctly reference AWS::URLSuffix in hotswappable changes" time="0.025">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode can correctly reference Fn::ImportValue in hotswappable changes" name="&quot;hotswap-only&quot; mode can correctly reference Fn::ImportValue in hotswappable changes" time="0.017">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode A change to both a hotswappable resource and a stack output results in a full deployment for HOTSWAP and a hotswap deployment for HOTSWAP_ONLY" name="&quot;hotswap-only&quot; mode A change to both a hotswappable resource and a stack output results in a full deployment for HOTSWAP and a hotswap deployment for HOTSWAP_ONLY" time="0.02">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode Multiple CfnEvaluationException will not cause unhandled rejections" name="&quot;hotswap-only&quot; mode Multiple CfnEvaluationException will not cause unhandled rejections" time="0.017">
    </testcase>
  </testsuite>
  <testsuite name="tests that use assets" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:04" time="1.521" tests="11">
    <testcase classname="tests that use assets a more complex way to make a cycle" name="tests that use assets a more complex way to make a cycle" time="0.09">
    </testcase>
    <testcase classname="tests that use assets assets with shared contents between dependant stacks" name="tests that use assets assets with shared contents between dependant stacks" time="0.069">
    </testcase>
    <testcase classname="tests that use assets the same asset to different destinations is only built once" name="tests that use assets the same asset to different destinations is only built once" time="0.027">
    </testcase>
    <testcase classname="tests that use assets different parameters for the same named definition are both published" name="tests that use assets different parameters for the same named definition are both published" time="0.015">
    </testcase>
    <testcase classname="with some stacks and assets asset publishing step depends on asset building step" name="with some stacks and assets asset publishing step depends on asset building step" time="0.008">
    </testcase>
    <testcase classname="with some stacks and assets with prebuild on, assets only have their own dependencies" name="with some stacks and assets with prebuild on, assets only have their own dependencies" time="0.009">
    </testcase>
    <testcase classname="with some stacks and assets with prebuild off, asset building inherits dependencies from their parent stack" name="with some stacks and assets with prebuild off, asset building inherits dependencies from their parent stack" time="0.012">
    </testcase>
    <testcase classname="with some stacks and assets stack depends on the asset publishing step" name="with some stacks and assets stack depends on the asset publishing step" time="0.014">
    </testcase>
    <testcase classname=" tree metadata is ignored" name=" tree metadata is ignored" time="0.006">
    </testcase>
    <testcase classname=" dependencies on unselected artifacts are silently ignored" name=" dependencies on unselected artifacts are silently ignored" time="0.007">
    </testcase>
    <testcase classname=" can handle nested assemblies" name=" can handle nested assemblies" time="0.019">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:03" time="1.759" tests="2">
    <testcase classname=" empty result when service details cannot be retrieved" name=" empty result when service details cannot be retrieved" time="0.002">
    </testcase>
    <testcase classname=" returns availability zones" name=" returns availability zones" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="Lazy ListStackResources" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:04" time="2.054" tests="1">
    <testcase classname="Lazy ListStackResources correctly caches calls to the CloudFormation API" name="Lazy ListStackResources correctly caches calls to the CloudFormation API" time="0.004">
    </testcase>
  </testsuite>
  <testsuite name="LazyLookupExport" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:05" time="2.022" tests="6">
    <testcase classname="LazyLookupExport three pages of exports paginates" name="LazyLookupExport three pages of exports paginates" time="0.005">
    </testcase>
    <testcase classname="LazyLookupExport three pages of exports stops fetching once export is found" name="LazyLookupExport three pages of exports stops fetching once export is found" time="0.006">
    </testcase>
    <testcase classname="LazyLookupExport three pages of exports returns the matching export" name="LazyLookupExport three pages of exports returns the matching export" time="0.003">
    </testcase>
    <testcase classname="LazyLookupExport three pages of exports returns undefined if the export does not exist" name="LazyLookupExport three pages of exports returns undefined if the export does not exist" time="0.011">
    </testcase>
    <testcase classname="LazyLookupExport three pages of exports caches the calls to CloudFormation API" name="LazyLookupExport three pages of exports caches the calls to CloudFormation API" time="0.003">
    </testcase>
    <testcase classname="LazyLookupExport skips over any results that omit Name property" name="LazyLookupExport skips over any results that omit Name property" time="0.009">
    </testcase>
  </testsuite>
  <testsuite name="determineAllowCrossAccountAssetPublishing" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:05" time="2.461" tests="12">
    <testcase classname="determineAllowCrossAccountAssetPublishing should return true when the bucket output does not look like a real bucket" name="determineAllowCrossAccountAssetPublishing should return true when the bucket output does not look like a real bucket" time="0.002">
    </testcase>
    <testcase classname="determineAllowCrossAccountAssetPublishing should return true if looking up the bootstrap stack fails" name="determineAllowCrossAccountAssetPublishing should return true if looking up the bootstrap stack fails" time="0.002">
    </testcase>
    <testcase classname="determineAllowCrossAccountAssetPublishing should return true when the bucket output does not look like a real bucket" name="determineAllowCrossAccountAssetPublishing should return true when the bucket output does not look like a real bucket" time="0.003">
    </testcase>
    <testcase classname="determineAllowCrossAccountAssetPublishing should return true if looking up the bootstrap stack fails" name="determineAllowCrossAccountAssetPublishing should return true if looking up the bootstrap stack fails" time="0.01">
    </testcase>
    <testcase classname="determineAllowCrossAccountAssetPublishing should return true when the bucket output does not look like a real bucket" name="determineAllowCrossAccountAssetPublishing should return true when the bucket output does not look like a real bucket" time="0.008">
    </testcase>
    <testcase classname="determineAllowCrossAccountAssetPublishing should return true when the bucket output does not look like a real bucket" name="determineAllowCrossAccountAssetPublishing should return true when the bucket output does not look like a real bucket" time="0.006">
    </testcase>
    <testcase classname="determineAllowCrossAccountAssetPublishing should return false for other scenarios" name="determineAllowCrossAccountAssetPublishing should return false for other scenarios" time="0.001">
    </testcase>
    <testcase classname="determineAllowCrossAccountAssetPublishing should return true when hasStagingBucket is false" name="determineAllowCrossAccountAssetPublishing should return true when hasStagingBucket is false" time="0">
    </testcase>
    <testcase classname="determineAllowCrossAccountAssetPublishing should return true when bootstrap version is &gt;= 21" name="determineAllowCrossAccountAssetPublishing should return true when bootstrap version is &gt;= 21" time="0.003">
    </testcase>
    <testcase classname="getBootstrapStackInfo should throw error when stack is not found" name="getBootstrapStackInfo should throw error when stack is not found" time="0.013">
    </testcase>
    <testcase classname="getBootstrapStackInfo should throw error when BootstrapVersion output is missing" name="getBootstrapStackInfo should throw error when BootstrapVersion output is missing" time="0.002">
    </testcase>
    <testcase classname="getBootstrapStackInfo should return correct BootstrapStackInfo" name="getBootstrapStackInfo should return correct BootstrapStackInfo" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:05" time="2.226" tests="9">
    <testcase classname=" allows specifying the subnet group name tag" name=" allows specifying the subnet group name tag" time="0.029">
    </testcase>
    <testcase classname=" looks up the requested (symmetric) VPC" name=" looks up the requested (symmetric) VPC" time="0.045">
    </testcase>
    <testcase classname=" uses the VPC main route table when a subnet has no specific association" name=" uses the VPC main route table when a subnet has no specific association" time="0.038">
    </testcase>
    <testcase classname=" works for asymmetric subnets (not spanning the same Availability Zones)" name=" works for asymmetric subnets (not spanning the same Availability Zones)" time="0.016">
    </testcase>
    <testcase classname=" throws when multiple VPCs are found" name=" throws when multiple VPCs are found" time="0.022">
    </testcase>
    <testcase classname=" Recognize private subnet by route table" name=" Recognize private subnet by route table" time="0.013">
    </testcase>
    <testcase classname=" Recognize isolated subnet by route table" name=" Recognize isolated subnet by route table" time="0.01">
    </testcase>
    <testcase classname=" Recognize public subnet by route table" name=" Recognize public subnet by route table" time="0.059">
    </testcase>
    <testcase classname=" throws when no such VPC is found" name=" throws when no such VPC is found" time="0.005">
    </testcase>
  </testsuite>
  <testsuite name="stack monitor event ordering and pagination" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:06" time="2.564" tests="8">
    <testcase classname="stack monitor event ordering and pagination do a final request after the monitor is stopped" name="stack monitor event ordering and pagination do a final request after the monitor is stopped" time="0.055">
    </testcase>
    <testcase classname="stack monitor event ordering and pagination do not page further if the last event is too old" name="stack monitor event ordering and pagination do not page further if the last event is too old" time="0.009">
    </testcase>
    <testcase classname="stack monitor event ordering and pagination do not page further if we already saw the last event" name="stack monitor event ordering and pagination do not page further if we already saw the last event" time="0.021">
    </testcase>
    <testcase classname="stack monitor event ordering and pagination continue to the next page if it exists" name="stack monitor event ordering and pagination continue to the next page if it exists" time="0.043">
    </testcase>
    <testcase classname="stack monitor, collecting errors from events does not check for nested stacks that have already completed successfully" name="stack monitor, collecting errors from events does not check for nested stacks that have already completed successfully" time="0.028">
    </testcase>
    <testcase classname="stack monitor, collecting errors from events return errors from the nested stack" name="stack monitor, collecting errors from events return errors from the nested stack" time="0.019">
    </testcase>
    <testcase classname="stack monitor, collecting errors from events return errors from the root stack" name="stack monitor, collecting errors from events return errors from the root stack" time="0.013">
    </testcase>
    <testcase classname="stack monitor, collecting errors from events does not consider events without physical resource id for monitoring nested stacks" name="stack monitor, collecting errors from events does not consider events without physical resource id for monitoring nested stacks" time="0.011">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:08" time="1.197" tests="8">
    <testcase classname=" deepGet can return an array" name=" deepGet can return an array" time="0">
    </testcase>
    <testcase classname="splitBySize objects are split at the right place" name="splitBySize objects are split at the right place" time="0.291">
    </testcase>
    <testcase classname=" deepGet can get deeply" name=" deepGet can get deeply" time="0">
    </testcase>
    <testcase classname=" deepMerge overwrites non-objects" name=" deepMerge overwrites non-objects" time="0">
    </testcase>
    <testcase classname=" deepMerge merges objects" name=" deepMerge merges objects" time="0">
    </testcase>
    <testcase classname=" changing deepClones copy leaves the original intact" name=" changing deepClones copy leaves the original intact" time="0">
    </testcase>
    <testcase classname=" deepSet can set deeply" name=" deepSet can set deeply" time="0">
    </testcase>
    <testcase classname=" deepMerge does not overwrite if rightmost is &quot;undefined&quot;" name=" deepMerge does not overwrite if rightmost is &quot;undefined&quot;" time="0">
    </testcase>
  </testsuite>
  <testsuite name="poll" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:07" time="2.043" tests="2">
    <testcase classname="poll does not poll unnecessary pages" name="poll does not poll unnecessary pages" time="0.004">
    </testcase>
    <testcase classname="poll polls all necessary pages" name="poll polls all necessary pages" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="&quot;fall-back&quot; mode" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:06" time="3.672" tests="2">
    <testcase classname="&quot;fall-back&quot; mode A change to an IAM Policy results in a full deployment for HOTSWAP and a noOp for HOTSWAP_ONLY" name="&quot;fall-back&quot; mode A change to an IAM Policy results in a full deployment for HOTSWAP and a noOp for HOTSWAP_ONLY" time="0.742">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode A change to an IAM Policy results in a full deployment for HOTSWAP and a noOp for HOTSWAP_ONLY" name="&quot;hotswap-only&quot; mode A change to an IAM Policy results in a full deployment for HOTSWAP and a noOp for HOTSWAP_ONLY" time="0.073">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:09" time="1.332" tests="8">
    <testcase classname=" prints 1/4 progress report, when addActivity is called with an &quot;UPDATE_COMPLETE&quot; ResourceStatus" name=" prints 1/4 progress report, when addActivity is called with an &quot;UPDATE_COMPLETE&quot; ResourceStatus" time="0.005">
    </testcase>
    <testcase classname=" print failed resources because of hook failures" name=" print failed resources because of hook failures" time="0.017">
    </testcase>
    <testcase classname=" prints 1/4 progress report, when addActivity is called with an &quot;UPDATE_COMPLETE&quot; ResourceStatus" name=" prints 1/4 progress report, when addActivity is called with an &quot;UPDATE_COMPLETE&quot; ResourceStatus" time="0.001">
    </testcase>
    <testcase classname=" does not print &quot;Failed Resources:&quot; list, when all deployments are successful" name=" does not print &quot;Failed Resources:&quot; list, when all deployments are successful" time="0">
    </testcase>
    <testcase classname=" prints 0/4 progress report, when addActivity is called with an &quot;UPDATE_FAILED&quot; ResourceStatus" name=" prints 0/4 progress report, when addActivity is called with an &quot;UPDATE_FAILED&quot; ResourceStatus" time="0.009">
    </testcase>
    <testcase classname=" prints 1/4 progress report, when addActivity is called with an &quot;ROLLBACK_COMPLETE&quot; ResourceStatus" name=" prints 1/4 progress report, when addActivity is called with an &quot;ROLLBACK_COMPLETE&quot; ResourceStatus" time="0.005">
    </testcase>
    <testcase classname=" prints 0/4 progress report, when addActivity is called with an &quot;IN_PROGRESS&quot; ResourceStatus" name=" prints 0/4 progress report, when addActivity is called with an &quot;IN_PROGRESS&quot; ResourceStatus" time="0">
    </testcase>
    <testcase classname=" prints &quot;Failed Resources:&quot; list, when at least one deployment fails" name=" prints &quot;Failed Resources:&quot; list, when at least one deployment fails" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="file assets" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:07" time="3.165" tests="7">
    <testcase classname="file assets reuse" name="file assets reuse" time="0.014">
    </testcase>
    <testcase classname="file assets hash and ID the same =&gt; only one path component" name="file assets hash and ID the same =&gt; only one path component" time="0.007">
    </testcase>
    <testcase classname="file assets convert to manifest and parameters" name="file assets convert to manifest and parameters" time="0.006">
    </testcase>
    <testcase classname="docker assets if parameter is left out then repo and tag are required" name="docker assets if parameter is left out then repo and tag are required" time="0.062">
    </testcase>
    <testcase classname="docker assets parameter and no repository name (old)" name="docker assets parameter and no repository name (old)" time="0.016">
    </testcase>
    <testcase classname="docker assets no parameter and repo/tag name (new)" name="docker assets no parameter and repo/tag name (new)" time="0.012">
    </testcase>
    <testcase classname="docker assets reuse" name="docker assets reuse" time="0.01">
    </testcase>
  </testsuite>
  <testsuite name="formatErrorMessage" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:10" time="1.712" tests="3">
    <testcase classname="formatErrorMessage should return the formatted message for an AggregateError" name="formatErrorMessage should return the formatted message for an AggregateError" time="0">
    </testcase>
    <testcase classname="formatErrorMessage should return &quot;Unknown error&quot; for null or undefined error" name="formatErrorMessage should return &quot;Unknown error&quot; for null or undefined error" time="0.001">
    </testcase>
    <testcase classname="formatErrorMessage should return the formatted message for a regular Error object" name="formatErrorMessage should return the formatted message for a regular Error object" time="0">
    </testcase>
  </testsuite>
  <testsuite name="evaluateCfnExpression" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:09" time="3.457" tests="6">
    <testcase classname="evaluateCfnExpression resolving Fn::ImportValue resolves Fn::ImportValue using lookup" name="evaluateCfnExpression resolving Fn::ImportValue resolves Fn::ImportValue using lookup" time="0.014">
    </testcase>
    <testcase classname="evaluateCfnExpression resolving Fn::ImportValue throws error when Fn::ImportValue cannot be resolved" name="evaluateCfnExpression resolving Fn::ImportValue throws error when Fn::ImportValue cannot be resolved" time="0.009">
    </testcase>
    <testcase classname="evaluateCfnExpression simple literal expressions resolves Fn::Split correctly" name="evaluateCfnExpression simple literal expressions resolves Fn::Split correctly" time="0.002">
    </testcase>
    <testcase classname="evaluateCfnExpression simple literal expressions resolves Fn::Join correctly" name="evaluateCfnExpression simple literal expressions resolves Fn::Join correctly" time="0">
    </testcase>
    <testcase classname="evaluateCfnExpression simple literal expressions resolves Fn::Select correctly" name="evaluateCfnExpression simple literal expressions resolves Fn::Select correctly" time="0">
    </testcase>
    <testcase classname="evaluateCfnExpression simple literal expressions resolves Fn::Sub correctly" name="evaluateCfnExpression simple literal expressions resolves Fn::Sub correctly" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="ssmParameters" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:10" time="3.386" tests="2">
    <testcase classname="ssmParameters errors when parameter is not found" name="ssmParameters errors when parameter is not found" time="0.015">
    </testcase>
    <testcase classname="ssmParameters returns value" name="ssmParameters returns value" time="0.003">
    </testcase>
  </testsuite>
  <testsuite name="non-nested stacks" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:08" time="5.716" tests="20">
    <testcase classname="non-nested stacks throws an error if no valid stack names given" name="non-nested stacks throws an error if no valid stack names given" time="0.064">
    </testcase>
    <testcase classname="non-nested stacks diff number of stack diffs, not resource diffs" name="non-nested stacks diff number of stack diffs, not resource diffs" time="0.012">
    </testcase>
    <testcase classname="non-nested stacks when quiet mode is enabled, stacks with diffs should print stack name to stdout" name="non-nested stacks when quiet mode is enabled, stacks with diffs should print stack name to stdout" time="0.008">
    </testcase>
    <testcase classname="non-nested stacks exits with 1 with diffs and fail set to true" name="non-nested stacks exits with 1 with diffs and fail set to true" time="0.305">
    </testcase>
    <testcase classname="non-nested stacks when quiet mode is enabled, stacks with no diffs should not print stack name &amp; no differences to stdout" name="non-nested stacks when quiet mode is enabled, stacks with no diffs should not print stack name &amp; no differences to stdout" time="0.009">
    </testcase>
    <testcase classname="non-nested stacks exits with 1 with diff in first stack, but not in second stack and fail set to true" name="non-nested stacks exits with 1 with diff in first stack, but not in second stack and fail set to true" time="0.024">
    </testcase>
    <testcase classname="non-nested stacks diff can diff multiple stacks" name="non-nested stacks diff can diff multiple stacks" time="0.008">
    </testcase>
    <testcase classname="non-nested stacks throws an error during diffs on stack with error metadata" name="non-nested stacks throws an error during diffs on stack with error metadata" time="0.019">
    </testcase>
    <testcase classname="nested stacks when quiet mode is enabled, nested stacks with diffs should print stack name to stdout" name="nested stacks when quiet mode is enabled, nested stacks with diffs should print stack name to stdout" time="1.725">
    </testcase>
    <testcase classname="nested stacks diff falls back to non-changeset diff for nested stacks" name="nested stacks diff falls back to non-changeset diff for nested stacks" time="0.052">
    </testcase>
    <testcase classname="nested stacks diff can diff nested stacks and display the nested stack logical ID if has not been deployed or otherwise has no physical name" name="nested stacks diff can diff nested stacks and display the nested stack logical ID if has not been deployed or otherwise has no physical name" time="0.072">
    </testcase>
    <testcase classname="nested stacks when quiet mode is enabled, nested stacks with no diffs should not print stack name &amp; no differences to stdout" name="nested stacks when quiet mode is enabled, nested stacks with no diffs should not print stack name &amp; no differences to stdout" time="0.018">
    </testcase>
    <testcase classname="--strict --strict does not obscure CDK::Metadata or CheckBootstrapVersion" name="--strict --strict does not obscure CDK::Metadata or CheckBootstrapVersion" time="0.026">
    </testcase>
    <testcase classname="--strict --no-strict obscures CDK::Metadata and CheckBootstrapVersion" name="--strict --no-strict obscures CDK::Metadata and CheckBootstrapVersion" time="0.039">
    </testcase>
    <testcase classname="imports imports render correctly for a nonexistant stack without creating a changeset" name="imports imports render correctly for a nonexistant stack without creating a changeset" time="0.04">
    </testcase>
    <testcase classname="imports imports render correctly for an existing stack and diff creates a changeset" name="imports imports render correctly for an existing stack and diff creates a changeset" time="0.007">
    </testcase>
    <testcase classname="stack exists checks diff falls back to classic diff when stack does not exist" name="stack exists checks diff falls back to classic diff when stack does not exist" time="0.009">
    </testcase>
    <testcase classname="stack exists checks diff falls back to classic diff when stackExists call fails" name="stack exists checks diff falls back to classic diff when stackExists call fails" time="0.011">
    </testcase>
    <testcase classname="stack exists checks diff does not check for stack existence when --no-change-set is passed" name="stack exists checks diff does not check for stack existence when --no-change-set is passed" time="0.012">
    </testcase>
    <testcase classname="fixed template fixed template with valid templates" name="fixed template fixed template with valid templates" time="0.131">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:13" time="1.373" tests="6">
    <testcase classname=" converts 1024 bytes to 1 KiB" name=" converts 1024 bytes to 1 KiB" time="0.001">
    </testcase>
    <testcase classname=" can format many decimals" name=" can format many decimals" time="0">
    </testcase>
    <testcase classname=" can deal with negative decimals" name=" can deal with negative decimals" time="0">
    </testcase>
    <testcase classname=" converts 10 bytes to 10 Bytes" name=" converts 10 bytes to 10 Bytes" time="0">
    </testcase>
    <testcase classname=" converts 11010048 bytes to 10.5 MiB" name=" converts 11010048 bytes to 10.5 MiB" time="0">
    </testcase>
    <testcase classname=" converts 0 bytes to 0 Bytes" name=" converts 0 bytes to 0 Bytes" time="0">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:11" time="3.837" tests="5">
    <testcase classname=" plugin context provider can be called without account/region" name=" plugin context provider can be called without account/region" time="0.001">
    </testcase>
    <testcase classname=" errors are reported into the context value" name=" errors are reported into the context value" time="0.001">
    </testcase>
    <testcase classname=" lookup role ARN is resolved" name=" lookup role ARN is resolved" time="0.004">
    </testcase>
    <testcase classname=" context provider can be registered using PluginHost" name=" context provider can be registered using PluginHost" time="0.001">
    </testcase>
    <testcase classname=" errors are marked transient" name=" errors are marked transient" time="0">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:14" time="0.943" tests="8">
    <testcase classname=" &quot;2&quot; is in range: false" name=" &quot;2&quot; is in range: false" time="0.002">
    </testcase>
    <testcase classname=" &quot;4.2.294-220.533.amzn2.x86_64&quot; is in range: true" name=" &quot;4.2.294-220.533.amzn2.x86_64&quot; is in range: true" time="0">
    </testcase>
    <testcase classname=" &quot;2.2&quot; is in range: true" name=" &quot;2.2&quot; is in range: true" time="0">
    </testcase>
    <testcase classname=" &quot;4.3&quot; is in range: true" name=" &quot;4.3&quot; is in range: true" time="0">
    </testcase>
    <testcase classname=" &quot;4&quot; is in range: false" name=" &quot;4&quot; is in range: false" time="0">
    </testcase>
    <testcase classname=" &quot;3&quot; is in range: true" name=" &quot;3&quot; is in range: true" time="0.001">
    </testcase>
    <testcase classname=" &quot;2.1&quot; is in range: false" name=" &quot;2.1&quot; is in range: false" time="0">
    </testcase>
    <testcase classname=" &quot;4.3&quot; is in range: true" name=" &quot;4.3&quot; is in range: true" time="0">
    </testcase>
  </testsuite>
  <testsuite name="CliIoHost" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:15" time="1.225" tests="28">
    <testcase classname="CliIoHost message formatting outputs debugs in gray color " name="CliIoHost message formatting outputs debugs in gray color " time="0.001">
    </testcase>
    <testcase classname="CliIoHost message formatting outputs errors in red color " name="CliIoHost message formatting outputs errors in red color " time="0">
    </testcase>
    <testcase classname="CliIoHost message formatting outputs traces in gray color " name="CliIoHost message formatting outputs traces in gray color " time="0">
    </testcase>
    <testcase classname="CliIoHost message formatting applies no styling when TTY is false" name="CliIoHost message formatting applies no styling when TTY is false" time="0">
    </testcase>
    <testcase classname="CliIoHost message formatting formats debug messages with timestamp" name="CliIoHost message formatting formats debug messages with timestamp" time="0">
    </testcase>
    <testcase classname="CliIoHost message formatting formats trace messages with timestamp" name="CliIoHost message formatting formats trace messages with timestamp" time="0.001">
    </testcase>
    <testcase classname="CliIoHost message formatting outputs warns in yellow color " name="CliIoHost message formatting outputs warns in yellow color " time="0">
    </testcase>
    <testcase classname="CliIoHost message formatting outputs infos in white color " name="CliIoHost message formatting outputs infos in white color " time="0">
    </testcase>
    <testcase classname="CliIoHost CI mode behavior writes to stderr for error level in CI mode" name="CliIoHost CI mode behavior writes to stderr for error level in CI mode" time="0.001">
    </testcase>
    <testcase classname="CliIoHost CI mode behavior writes to stdout in CI mode when level is not error" name="CliIoHost CI mode behavior writes to stdout in CI mode when level is not error" time="0">
    </testcase>
    <testcase classname="CliIoHost timestamp handling includes timestamp for DEBUG level with gray color" name="CliIoHost timestamp handling includes timestamp for DEBUG level with gray color" time="0.001">
    </testcase>
    <testcase classname="CliIoHost timestamp handling excludes timestamp for other levels but includes color" name="CliIoHost timestamp handling excludes timestamp for other levels but includes color" time="0">
    </testcase>
    <testcase classname="CliIoHost stream selection writes to stderr for error level with red color" name="CliIoHost stream selection writes to stderr for error level with red color" time="0">
    </testcase>
    <testcase classname="CliIoHost stream selection writes to stderr by default for non-error messages in non-CI mode" name="CliIoHost stream selection writes to stderr by default for non-error messages in non-CI mode" time="0">
    </testcase>
    <testcase classname="CliIoHost stream selection writes to stdout for result level" name="CliIoHost stream selection writes to stdout for result level" time="0">
    </testcase>
    <testcase classname="CliIoHost requestResponse non-promptable data logs messages and returns default unchanged" name="CliIoHost requestResponse non-promptable data logs messages and returns default unchanged" time="0.001">
    </testcase>
    <testcase classname="CliIoHost requestResponse string receives &quot;
&quot; and returns &quot;cat&quot;" name="CliIoHost requestResponse string receives &quot;
&quot; and returns &quot;cat&quot;" time="0.002">
    </testcase>
    <testcase classname="CliIoHost requestResponse string receives &quot;giraffe&quot; and returns &quot;giraffe&quot;" name="CliIoHost requestResponse string receives &quot;giraffe&quot; and returns &quot;giraffe&quot;" time="0.001">
    </testcase>
    <testcase classname="CliIoHost requestResponse string receives &quot;bear&quot; and returns &quot;bear&quot;" name="CliIoHost requestResponse string receives &quot;bear&quot; and returns &quot;bear&quot;" time="0">
    </testcase>
    <testcase classname="CliIoHost requestResponse boolean respond &quot;yes&quot; to a confirmation prompt" name="CliIoHost requestResponse boolean respond &quot;yes&quot; to a confirmation prompt" time="0">
    </testcase>
    <testcase classname="CliIoHost requestResponse boolean respond &quot;no&quot; to a confirmation prompt" name="CliIoHost requestResponse boolean respond &quot;no&quot; to a confirmation prompt" time="0.017">
    </testcase>
    <testcase classname="CliIoHost requestResponse non TTY environment fail with specific motivation" name="CliIoHost requestResponse non TTY environment fail with specific motivation" time="0.014">
    </testcase>
    <testcase classname="CliIoHost requestResponse non TTY environment fail for all prompts" name="CliIoHost requestResponse non TTY environment fail for all prompts" time="0.001">
    </testcase>
    <testcase classname="CliIoHost requestResponse non TTY environment returns the default for non-promptable requests" name="CliIoHost requestResponse non TTY environment returns the default for non-promptable requests" time="0.001">
    </testcase>
    <testcase classname="CliIoHost requestResponse number receives &quot;3&quot; and return 3" name="CliIoHost requestResponse number receives &quot;3&quot; and return 3" time="0">
    </testcase>
    <testcase classname="CliIoHost requestResponse number receives &quot;
&quot; and return 1" name="CliIoHost requestResponse number receives &quot;
&quot; and return 1" time="0.001">
    </testcase>
    <testcase classname="CliIoHost requestResponse fail if concurrency is &gt; 1" name="CliIoHost requestResponse fail if concurrency is &gt; 1" time="0">
    </testcase>
    <testcase classname="CliIoHost action handling sets and gets current action" name="CliIoHost action handling sets and gets current action" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="&quot;fall-back&quot; mode" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:12" time="4.163" tests="6">
    <testcase classname="&quot;fall-back&quot; mode hotswaps a Version and an Alias if the Function they point to changed" name="&quot;fall-back&quot; mode hotswaps a Version and an Alias if the Function they point to changed" time="1.075">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode hotswaps a Version if it points to a changed Function, even if it itself is replaced" name="&quot;fall-back&quot; mode hotswaps a Version if it points to a changed Function, even if it itself is replaced" time="0.034">
    </testcase>
    <testcase classname="&quot;fall-back&quot; mode hotswaps a Version if it points to a changed Function, even if it itself is unchanged" name="&quot;fall-back&quot; mode hotswaps a Version if it points to a changed Function, even if it itself is unchanged" time="0.051">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode hotswaps a Version if it points to a changed Function, even if it itself is unchanged" name="&quot;hotswap-only&quot; mode hotswaps a Version if it points to a changed Function, even if it itself is unchanged" time="0.015">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode hotswaps a Version and an Alias if the Function they point to changed" name="&quot;hotswap-only&quot; mode hotswaps a Version and an Alias if the Function they point to changed" time="0.014">
    </testcase>
    <testcase classname="&quot;hotswap-only&quot; mode hotswaps a Version if it points to a changed Function, even if it itself is replaced" name="&quot;hotswap-only&quot; mode hotswaps a Version if it points to a changed Function, even if it itself is replaced" time="0.036">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:14" time="2.178" tests="2">
    <testcase classname=" empty array as result when response has no AZs" name=" empty array as result when response has no AZs" time="0.007">
    </testcase>
    <testcase classname=" returns AZs" name=" returns AZs" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:14" time="2.986" tests="15">
    <testcase classname=" if an unsupplied parameter reverts to its default, it can still be dirty" name=" if an unsupplied parameter reverts to its default, it can still be dirty" time="0.003">
    </testcase>
    <testcase classname=" A non-existent stack pretends to have an empty template" name=" A non-existent stack pretends to have an empty template" time="0.003">
    </testcase>
    <testcase classname=" if a parameter is retrieved from SSM, the parameters always count as changed" name=" if a parameter is retrieved from SSM, the parameters always count as changed" time="0.001">
    </testcase>
    <testcase classname=" unknown parameter in overrides, pass it anyway" name=" unknown parameter in overrides, pass it anyway" time="0.002">
    </testcase>
    <testcase classname=" if a parameter is retrieved from SSM, the parameters doesnt count as changed if it has the magic marker" name=" if a parameter is retrieved from SSM, the parameters doesnt count as changed if it has the magic marker" time="0.009">
    </testcase>
    <testcase classname=" empty string is a valid update value" name=" empty string is a valid update value" time="0.001">
    </testcase>
    <testcase classname=" no default, no prev, no override =&gt; error" name=" no default, no prev, no override =&gt; error" time="0.031">
    </testcase>
    <testcase classname=" given override, always use the override (parameter has a default: false, parameter previously supplied: true)" name=" given override, always use the override (parameter has a default: false, parameter previously supplied: true)" time="0.001">
    </testcase>
    <testcase classname=" given override, always use the override (parameter has a default: false, parameter previously supplied: false)" name=" given override, always use the override (parameter has a default: false, parameter previously supplied: false)" time="0">
    </testcase>
    <testcase classname=" Retrieving a processed template passes &apos;Processed&apos; to CloudFormation" name=" Retrieving a processed template passes &apos;Processed&apos; to CloudFormation" time="0.001">
    </testcase>
    <testcase classname=" default, prev, no override =&gt; use previous" name=" default, prev, no override =&gt; use previous" time="0.001">
    </testcase>
    <testcase classname=" no default, yes prev, no override =&gt; use previous" name=" no default, yes prev, no override =&gt; use previous" time="0">
    </testcase>
    <testcase classname=" default, no prev, no override =&gt; empty param set (and obviously changes to be applied)" name=" default, no prev, no override =&gt; empty param set (and obviously changes to be applied)" time="0">
    </testcase>
    <testcase classname=" given override, always use the override (parameter has a default: true, parameter previously supplied: false)" name=" given override, always use the override (parameter has a default: true, parameter previously supplied: false)" time="0">
    </testcase>
    <testcase classname=" given override, always use the override (parameter has a default: true, parameter previously supplied: true)" name=" given override, always use the override (parameter has a default: true, parameter previously supplied: true)" time="0">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:16" time="1.584" tests="3">
    <testcase classname=" can convert writer to reader lock" name=" can convert writer to reader lock" time="0.009">
    </testcase>
    <testcase classname=" writer lock excludes other locks" name=" writer lock excludes other locks" time="0.012">
    </testcase>
    <testcase classname=" reader lock allows other readers but not writers" name=" reader lock allows other readers but not writers" time="0.006">
    </testcase>
  </testsuite>
  <testsuite name="context --clear" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:17" time="1.384" tests="12">
    <testcase classname="context --clear can clear all context keys" name="context --clear can clear all context keys" time="0.004">
    </testcase>
    <testcase classname="context --list runs" name="context --list runs" time="0.007">
    </testcase>
    <testcase classname="context --reset throws when no key of index found" name="context --reset throws when no key of index found" time="0.015">
    </testcase>
    <testcase classname="context --reset can remove a context key using number" name="context --reset can remove a context key using number" time="0">
    </testcase>
    <testcase classname="context --reset throws when resetting read-only values" name="context --reset throws when resetting read-only values" time="0.001">
    </testcase>
    <testcase classname="context --reset throws when key not found" name="context --reset throws when key not found" time="0.002">
    </testcase>
    <testcase classname="context --reset throws when no matches could be reset" name="context --reset throws when no matches could be reset" time="0.001">
    </testcase>
    <testcase classname="context --reset doesn&apos;t throw when at least one match is reset" name="context --reset doesn&apos;t throw when at least one match is reset" time="0.001">
    </testcase>
    <testcase classname="context --reset can reset matched pattern" name="context --reset can reset matched pattern" time="0.001">
    </testcase>
    <testcase classname="context --reset prefers an exact match" name="context --reset prefers an exact match" time="0">
    </testcase>
    <testcase classname="context --reset Doesn&apos;t throw when key not found and --force is set" name="context --reset Doesn&apos;t throw when key not found and --force is set" time="0">
    </testcase>
    <testcase classname="context --reset can remove a context key" name="context --reset can remove a context key" time="0">
    </testcase>
  </testsuite>
  <testsuite name="deploy" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:40:45" time="33.185" tests="63">
    <testcase classname="deploy globless bootstrap uses environment without question" name="deploy globless bootstrap uses environment without question" time="0.009">
    </testcase>
    <testcase classname="deploy fails when no valid stack names are given" name="deploy fails when no valid stack names are given" time="0.174">
    </testcase>
    <testcase classname="deploy bootstrap can be invoked without the --app argument" name="deploy bootstrap can be invoked without the --app argument" time="0.006">
    </testcase>
    <testcase classname="deploy makes correct CloudFormation calls with one stack specified" name="deploy makes correct CloudFormation calls with one stack specified" time="0.024">
    </testcase>
    <testcase classname="deploy makes correct CloudFormation calls with stacks all stacks specified as wildcard" name="deploy makes correct CloudFormation calls with stacks all stacks specified as wildcard" time="0.012">
    </testcase>
    <testcase classname="deploy makes correct CloudFormation calls with stacks all stacks specified as double wildcard" name="deploy makes correct CloudFormation calls with stacks all stacks specified as double wildcard" time="0.013">
    </testcase>
    <testcase classname="deploy makes correct CloudFormation calls sns notification arns with sns notification arns in the executable and as options" name="deploy makes correct CloudFormation calls sns notification arns with sns notification arns in the executable and as options" time="0.014">
    </testcase>
    <testcase classname="deploy makes correct CloudFormation calls sns notification arns fail with incorrect sns notification arns as options" name="deploy makes correct CloudFormation calls sns notification arns fail with incorrect sns notification arns as options" time="0.027">
    </testcase>
    <testcase classname="deploy makes correct CloudFormation calls sns notification arns fail with incorrect sns notification arns in the executable and correct sns notification arns as options" name="deploy makes correct CloudFormation calls sns notification arns fail with incorrect sns notification arns in the executable and correct sns notification arns as options" time="0.027">
    </testcase>
    <testcase classname="deploy makes correct CloudFormation calls sns notification arns with sns notification arns as options" name="deploy makes correct CloudFormation calls sns notification arns with sns notification arns as options" time="0.011">
    </testcase>
    <testcase classname="deploy makes correct CloudFormation calls sns notification arns fail with incorrect sns notification arns in the executable" name="deploy makes correct CloudFormation calls sns notification arns fail with incorrect sns notification arns in the executable" time="0.011">
    </testcase>
    <testcase classname="deploy makes correct CloudFormation calls sns notification arns with sns notification arns in the executable" name="deploy makes correct CloudFormation calls sns notification arns with sns notification arns in the executable" time="0.014">
    </testcase>
    <testcase classname="deploy makes correct CloudFormation calls sns notification arns fail with correct sns notification arns in the executable and incorrect sns notification arns as options" name="deploy makes correct CloudFormation calls sns notification arns fail with correct sns notification arns in the executable and incorrect sns notification arns as options" time="0.017">
    </testcase>
    <testcase classname="deploy makes correct CloudFormation calls sns notification arns fail with incorrect sns notification arns in the executable and incorrect sns notification arns as options" name="deploy makes correct CloudFormation calls sns notification arns fail with incorrect sns notification arns in the executable and incorrect sns notification arns as options" time="0.012">
    </testcase>
    <testcase classname="deploy makes correct CloudFormation calls without options" name="deploy makes correct CloudFormation calls without options" time="0.013">
    </testcase>
    <testcase classname="deploy globby bootstrap uses whats in the stacks" name="deploy globby bootstrap uses whats in the stacks" time="0.016">
    </testcase>
    <testcase classname="deploy with hotswap deployment passes through the &apos;hotswap&apos; option to CloudFormationDeployments.deployStack()" name="deploy with hotswap deployment passes through the &apos;hotswap&apos; option to CloudFormationDeployments.deployStack()" time="0.018">
    </testcase>
    <testcase classname="watch observes only the root directory by default" name="watch observes only the root directory by default" time="0.004">
    </testcase>
    <testcase classname="watch ignores the output dir, dot files, dot directories, and node_modules by default" name="watch ignores the output dir, dot files, dot directories, and node_modules by default" time="0.003">
    </testcase>
    <testcase classname="watch allows providing a single string in &apos;watch.exclude&apos;" name="watch allows providing a single string in &apos;watch.exclude&apos;" time="0.004">
    </testcase>
    <testcase classname="watch fails when no &apos;watch&apos; settings are found" name="watch fails when no &apos;watch&apos; settings are found" time="0.005">
    </testcase>
    <testcase classname="watch allows providing an array of strings in &apos;watch.include&apos;" name="watch allows providing an array of strings in &apos;watch.include&apos;" time="0.003">
    </testcase>
    <testcase classname="watch respects HotswapMode.FULL_DEPLOYMENT" name="watch respects HotswapMode.FULL_DEPLOYMENT" time="0.003">
    </testcase>
    <testcase classname="watch allows providing an array of strings in &apos;watch.exclude&apos;" name="watch allows providing an array of strings in &apos;watch.exclude&apos;" time="0.003">
    </testcase>
    <testcase classname="watch allows providing a single string in &apos;watch.include&apos;" name="watch allows providing a single string in &apos;watch.include&apos;" time="0.003">
    </testcase>
    <testcase classname="watch &quot;hotswap-only&quot; mode passes through the correct hotswap mode to deployStack()" name="watch &quot;hotswap-only&quot; mode passes through the correct hotswap mode to deployStack()" time="0.003">
    </testcase>
    <testcase classname="watch respects HotswapMode.HOTSWAP_ONLY" name="watch respects HotswapMode.HOTSWAP_ONLY" time="0.002">
    </testcase>
    <testcase classname="watch with file change events when the &apos;ready&apos; event has already fired an initial &apos;deploy&apos; is triggered, without any file changes" name="watch with file change events when the &apos;ready&apos; event has already fired an initial &apos;deploy&apos; is triggered, without any file changes" time="0.005">
    </testcase>
    <testcase classname="watch with file change events when the &apos;ready&apos; event has already fired batches file changes that happen during &apos;deploy&apos;" name="watch with file change events when the &apos;ready&apos; event has already fired batches file changes that happen during &apos;deploy&apos;" time="0.003">
    </testcase>
    <testcase classname="watch with file change events when the &apos;ready&apos; event has already fired triggers a &apos;deploy&apos; twice for two file changes" name="watch with file change events when the &apos;ready&apos; event has already fired triggers a &apos;deploy&apos; twice for two file changes" time="0.002">
    </testcase>
    <testcase classname="watch with file change events when the &apos;ready&apos; event has already fired does trigger a &apos;deploy&apos; for a file change" name="watch with file change events when the &apos;ready&apos; event has already fired does trigger a &apos;deploy&apos; for a file change" time="0.003">
    </testcase>
    <testcase classname="watch with file change events does not trigger a &apos;deploy&apos; before the &apos;ready&apos; event has fired" name="watch with file change events does not trigger a &apos;deploy&apos; before the &apos;ready&apos; event has fired" time="0.003">
    </testcase>
    <testcase classname="watch allows watching with deploy concurrency" name="watch allows watching with deploy concurrency" time="0.003">
    </testcase>
    <testcase classname="watch respects HotswapMode.FALL_BACK" name="watch respects HotswapMode.FALL_BACK" time="0.002">
    </testcase>
    <testcase classname="watch &quot;fall-back&quot; mode passes through the correct hotswap mode to deployStack()" name="watch &quot;fall-back&quot; mode passes through the correct hotswap mode to deployStack()" time="0.003">
    </testcase>
    <testcase classname="synth successful synth outputs hierarchical stack ids" name="synth successful synth outputs hierarchical stack ids" time="0.016">
    </testcase>
    <testcase classname="synth no-rollback deployment that cant proceed will be called with rollback on retry: {&quot;type&quot;: &quot;replacement-requires-rollback&quot;} (using force: true)" name="synth no-rollback deployment that cant proceed will be called with rollback on retry: {&quot;type&quot;: &quot;replacement-requires-rollback&quot;} (using force: true)" time="0.012">
    </testcase>
    <testcase classname="synth stack has dependency and was explicitly selected" name="synth stack has dependency and was explicitly selected" time="0.012">
    </testcase>
    <testcase classname="synth rollback uses deployment role" name="synth rollback uses deployment role" time="0.019">
    </testcase>
    <testcase classname="synth with no stdout option" name="synth with no stdout option" time="0.016">
    </testcase>
    <testcase classname="synth stack has error and was explicitly selected" name="synth stack has error and was explicitly selected" time="0.013">
    </testcase>
    <testcase classname="synth stack with error and flagged for validation causes synth to succeed if autoValidate=false" name="synth stack with error and flagged for validation causes synth to succeed if autoValidate=false" time="0.013">
    </testcase>
    <testcase classname="synth stack with error and flagged for validation causes synth to fail if autoValidate=true" name="synth stack with error and flagged for validation causes synth to fail if autoValidate=true" time="0.008">
    </testcase>
    <testcase classname="synth no-rollback deployment that cant proceed will be called with rollback on retry: {&quot;reason&quot;: &quot;replacement&quot;, &quot;status&quot;: &quot;OOPS&quot;, &quot;type&quot;: &quot;failpaused-need-rollback-first&quot;} (using force: false)" name="synth no-rollback deployment that cant proceed will be called with rollback on retry: {&quot;reason&quot;: &quot;replacement&quot;, &quot;status&quot;: &quot;OOPS&quot;, &quot;type&quot;: &quot;failpaused-need-rollback-first&quot;} (using force: false)" time="0.008">
    </testcase>
    <testcase classname="synth migrate migrate call is idempotent" name="synth migrate migrate call is idempotent" time="1.958">
    </testcase>
    <testcase classname="synth migrate migrate succeeds for valid template from local path when language is provided" name="synth migrate migrate succeeds for valid template from local path when language is provided" time="3.509">
    </testcase>
    <testcase classname="synth migrate migrate fails when --from-path is invalid" name="synth migrate migrate fails when --from-path is invalid" time="0.013">
    </testcase>
    <testcase classname="synth migrate migrate fails when both --from-path and --from-stack are provided" name="synth migrate migrate fails when both --from-path and --from-stack are provided" time="0.003">
    </testcase>
    <testcase classname="synth migrate migrate fails when stack cannot be generated" name="synth migrate migrate fails when stack cannot be generated" time="0.004">
    </testcase>
    <testcase classname="synth migrate migrate succeeds for valid template from local path when no language is provided" name="synth migrate migrate succeeds for valid template from local path when no language is provided" time="23.787">
    </testcase>
    <testcase classname="synth migrate migrate fails when --from-stack is used and stack does not exist in account" name="synth migrate migrate fails when --from-stack is used and stack does not exist in account" time="0.016">
    </testcase>
    <testcase classname="synth stack has error, is not flagged for validation and was not explicitly selected" name="synth stack has error, is not flagged for validation and was not explicitly selected" time="0.06">
    </testcase>
    <testcase classname="synth no-rollback deployment that cant proceed will be called with rollback on retry: {&quot;reason&quot;: &quot;replacement&quot;, &quot;status&quot;: &quot;OOPS&quot;, &quot;type&quot;: &quot;failpaused-need-rollback-first&quot;} (using force: true)" name="synth no-rollback deployment that cant proceed will be called with rollback on retry: {&quot;reason&quot;: &quot;replacement&quot;, &quot;status&quot;: &quot;OOPS&quot;, &quot;type&quot;: &quot;failpaused-need-rollback-first&quot;} (using force: true)" time="0.014">
    </testcase>
    <testcase classname="synth no-rollback deployment that cant proceed will be called with rollback on retry: {&quot;type&quot;: &quot;replacement-requires-rollback&quot;} (using force: false)" name="synth no-rollback deployment that cant proceed will be called with rollback on retry: {&quot;type&quot;: &quot;replacement-requires-rollback&quot;} (using force: false)" time="0.011">
    </testcase>
    <testcase classname="synth no-rollback deployment that cant proceed will be called with rollback on retry: {&quot;reason&quot;: &quot;not-norollback&quot;, &quot;status&quot;: &quot;OOPS&quot;, &quot;type&quot;: &quot;failpaused-need-rollback-first&quot;} (using force: false)" name="synth no-rollback deployment that cant proceed will be called with rollback on retry: {&quot;reason&quot;: &quot;not-norollback&quot;, &quot;status&quot;: &quot;OOPS&quot;, &quot;type&quot;: &quot;failpaused-need-rollback-first&quot;} (using force: false)" time="0.01">
    </testcase>
    <testcase classname="bootstrap accepts qualifier from context" name="bootstrap accepts qualifier from context" time="0.005">
    </testcase>
    <testcase classname="destroy destroy correct stack" name="destroy destroy correct stack" time="0.006">
    </testcase>
    <testcase classname="readCurrentTemplate fallback to deploy role if bootstrap stack version is not valid" name="readCurrentTemplate fallback to deploy role if bootstrap stack version is not valid" time="0.034">
    </testcase>
    <testcase classname="readCurrentTemplate fallback to deploy role if forEnvironment throws" name="readCurrentTemplate fallback to deploy role if forEnvironment throws" time="0.018">
    </testcase>
    <testcase classname="readCurrentTemplate fallback to deploy role if bootstrap version parameter not found" name="readCurrentTemplate fallback to deploy role if bootstrap version parameter not found" time="0.014">
    </testcase>
    <testcase classname="readCurrentTemplate lookup role is used" name="readCurrentTemplate lookup role is used" time="0.013">
    </testcase>
    <testcase classname="readCurrentTemplate do not print warnings if lookup role not provided in stack artifact" name="readCurrentTemplate do not print warnings if lookup role not provided in stack artifact" time="0.011">
    </testcase>
    <testcase classname="readCurrentTemplate dont lookup bootstrap version parameter if default credentials are used" name="readCurrentTemplate dont lookup bootstrap version parameter if default credentials are used" time="0.016">
    </testcase>
  </testsuite>
  <testsuite name="list" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:15" time="2.766" tests="7">
    <testcase classname="list stacks with circular dependencies should error out" name="list stacks with circular dependencies should error out" time="0.046">
    </testcase>
    <testcase classname="list stacks with no dependencies" name="list stacks with no dependencies" time="0.008">
    </testcase>
    <testcase classname="list stacks with nested dependencies" name="list stacks with nested dependencies" time="0.028">
    </testcase>
    <testcase classname="list stacks with display names and have nested dependencies" name="list stacks with display names and have nested dependencies" time="0.017">
    </testcase>
    <testcase classname="list stacks with dependent stacks and have display name set to hieraricalId/stackName" name="list stacks with dependent stacks and have display name set to hieraricalId/stackName" time="0.006">
    </testcase>
    <testcase classname="list stacks with dependent stacks" name="list stacks with dependent stacks" time="0.009">
    </testcase>
    <testcase classname="list stacks with cross stack referencing" name="list stacks with cross stack referencing" time="0.005">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:18" time="0.192" tests="9">
    <testcase classname=" cannot save readonly values" name=" cannot save readonly values" time="0.011">
    </testcase>
    <testcase classname=" load context from both files if available" name=" load context from both files if available" time="0.004">
    </testcase>
    <testcase classname=" context is preserved in the location from which it is read" name=" context is preserved in the location from which it is read" time="0.018">
    </testcase>
    <testcase classname=" transient values arent saved to disk" name=" transient values arent saved to disk" time="0.007">
    </testcase>
    <testcase classname=" clear deletes from new file" name=" clear deletes from new file" time="0.006">
    </testcase>
    <testcase classname=" can save and load" name=" can save and load" time="0.005">
    </testcase>
    <testcase classname=" command line context is merged with stored context" name=" command line context is merged with stored context" time="0.006">
    </testcase>
    <testcase classname=" save no context in old file" name=" save no context in old file" time="0.007">
    </testcase>
    <testcase classname=" deleted context disappears from new file" name=" deleted context disappears from new file" time="0.006">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:18" time="0.73" tests="11">
    <testcase classname=" bundling stacks defaults to ** for watch" name=" bundling stacks defaults to ** for watch" time="0">
    </testcase>
    <testcase classname=" bundling stacks defaults to an empty list" name=" bundling stacks defaults to an empty list" time="0">
    </testcase>
    <testcase classname=" can parse string context from command line arguments with equals sign in value" name=" can parse string context from command line arguments with equals sign in value" time="0.002">
    </testcase>
    <testcase classname=" should include outputs-file in settings" name=" should include outputs-file in settings" time="0.001">
    </testcase>
    <testcase classname=" bundling stacks defaults to ** for deploy" name=" bundling stacks defaults to ** for deploy" time="0">
    </testcase>
    <testcase classname=" bundling stacks with watch exclusively" name=" bundling stacks with watch exclusively" time="0">
    </testcase>
    <testcase classname=" can parse string context from command line arguments" name=" can parse string context from command line arguments" time="0.001">
    </testcase>
    <testcase classname=" can parse tag values from command line arguments with equals sign in value" name=" can parse tag values from command line arguments with equals sign in value" time="0">
    </testcase>
    <testcase classname=" providing a build arg" name=" providing a build arg" time="0">
    </testcase>
    <testcase classname=" can parse tag values from command line arguments" name=" can parse tag values from command line arguments" time="0">
    </testcase>
    <testcase classname=" bundling stacks with deploy exclusively" name=" bundling stacks with deploy exclusively" time="0">
    </testcase>
  </testsuite>
  <testsuite name="load balancer context provider plugin" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:16" time="2.618" tests="15">
    <testcase classname="load balancer context provider plugin filters by type" name="load balancer context provider plugin filters by type" time="0.009">
    </testcase>
    <testcase classname="load balancer context provider plugin looks up by tags" name="load balancer context provider plugin looks up by tags" time="0.007">
    </testcase>
    <testcase classname="load balancer context provider plugin looks up by arn" name="load balancer context provider plugin looks up by arn" time="0.012">
    </testcase>
    <testcase classname="load balancer context provider plugin errors when multiple load balancers match" name="load balancer context provider plugin errors when multiple load balancers match" time="0.02">
    </testcase>
    <testcase classname="load balancer context provider plugin errors when no matches are found" name="load balancer context provider plugin errors when no matches are found" time="0.003">
    </testcase>
    <testcase classname="load balancer context provider plugin looks up by tags - query by subset" name="load balancer context provider plugin looks up by tags - query by subset" time="0.004">
    </testcase>
    <testcase classname="load balancer listener context provider plugin looks up by associated load balancer tags" name="load balancer listener context provider plugin looks up by associated load balancer tags" time="0.006">
    </testcase>
    <testcase classname="load balancer listener context provider plugin errors when multiple listeners match" name="load balancer listener context provider plugin errors when multiple listeners match" time="0.024">
    </testcase>
    <testcase classname="load balancer listener context provider plugin errors when associated load balancer is wrong type" name="load balancer listener context provider plugin errors when associated load balancer is wrong type" time="0.004">
    </testcase>
    <testcase classname="load balancer listener context provider plugin filters by associated load balancer type" name="load balancer listener context provider plugin filters by associated load balancer type" time="0.009">
    </testcase>
    <testcase classname="load balancer listener context provider plugin looks up by listener port and protocol" name="load balancer listener context provider plugin looks up by listener port and protocol" time="0.005">
    </testcase>
    <testcase classname="load balancer listener context provider plugin looks up by listener arn" name="load balancer listener context provider plugin looks up by listener arn" time="0.003">
    </testcase>
    <testcase classname="load balancer listener context provider plugin errors when no associated load balancers match" name="load balancer listener context provider plugin errors when no associated load balancers match" time="0.008">
    </testcase>
    <testcase classname="load balancer listener context provider plugin errors when no listeners match" name="load balancer listener context provider plugin errors when no listeners match" time="0.004">
    </testcase>
    <testcase classname="load balancer listener context provider plugin looks up by associated load balancer arn" name="load balancer listener context provider plugin looks up by associated load balancer arn" time="0.012">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:18" time="0.202" tests="5">
    <testcase classname=" array settings are not overridden by yarg defaults" name=" array settings are not overridden by yarg defaults" time="0.016">
    </testcase>
    <testcase classname=" load settings from both files if available" name=" load settings from both files if available" time="0.001">
    </testcase>
    <testcase classname=" load context from all 3 files if available" name=" load context from all 3 files if available" time="0">
    </testcase>
    <testcase classname=" Can specify the `quiet` key in the user config" name=" Can specify the `quiet` key in the user config" time="0.001">
    </testcase>
    <testcase classname=" throws an error if the `build` key is specified in the user config" name=" throws an error if the `build` key is specified in the user config" time="0">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:18" time="0.838" tests="5">
    <testcase classname=" cdk deploy -R sets rollback to false" name=" cdk deploy -R sets rollback to false" time="0.021">
    </testcase>
    <testcase classname="cdk docs for freebsd should return &quot;xdg-open %u&quot;" name="cdk docs for freebsd should return &quot;xdg-open %u&quot;" time="0.002">
    </testcase>
    <testcase classname="cdk docs for linux should return &quot;xdg-open %u&quot;" name="cdk docs for linux should return &quot;xdg-open %u&quot;" time="0.002">
    </testcase>
    <testcase classname="cdk docs for win32 should return &quot;start %u&quot;" name="cdk docs for win32 should return &quot;start %u&quot;" time="0.002">
    </testcase>
    <testcase classname="cdk docs for darwin should return &quot;open %u&quot;" name="cdk docs for darwin should return &quot;open %u&quot;" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="corked logging" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:19" time="0.169" tests="4">
    <testcase classname="corked logging maintains correct order with mixed log levels in corked block" name="corked logging maintains correct order with mixed log levels in corked block" time="0.002">
    </testcase>
    <testcase classname="corked logging buffers messages when corked" name="corked logging buffers messages when corked" time="0.001">
    </testcase>
    <testcase classname="corked logging handles errors in corked block while preserving buffer" name="corked logging handles errors in corked block while preserving buffer" time="0.014">
    </testcase>
    <testcase classname="corked logging handles nested corking correctly" name="corked logging handles nested corking correctly" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="yargs" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:19" time="0.197" tests="4">
    <testcase classname="yargs positional argument is correctly passed through -- single" name="yargs positional argument is correctly passed through -- single" time="0.006">
    </testcase>
    <testcase classname="yargs positional argument is correctly passed through -- variadic" name="yargs positional argument is correctly passed through -- variadic" time="0.004">
    </testcase>
    <testcase classname="yargs yargs object can be converted to cli arguments" name="yargs yargs object can be converted to cli arguments" time="0.003">
    </testcase>
    <testcase classname="config cdk.json arguments can be converted to cli argumets" name="config cdk.json arguments can be converted to cli argumets" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="validate sns arns" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:19" time="0.502" tests="5">
    <testcase classname="validate sns arns dash in topic name" name="validate sns arns dash in topic name" time="0.001">
    </testcase>
    <testcase classname="validate sns arns underscore in topic name" name="validate sns arns underscore in topic name" time="0">
    </testcase>
    <testcase classname="validate sns arns empty string" name="validate sns arns empty string" time="0">
    </testcase>
    <testcase classname="validate sns arns missing :aws: in arn" name="validate sns arns missing :aws: in arn" time="0">
    </testcase>
    <testcase classname="validate sns arns colon in topic name" name="validate sns arns colon in topic name" time="0">
    </testcase>
  </testsuite>
  <testsuite name="`cdk docs`" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:19" time="0.182" tests="2">
    <testcase classname="`cdk docs` exits with 0 when opening the browser fails" name="`cdk docs` exits with 0 when opening the browser fails" time="0.009">
    </testcase>
    <testcase classname="`cdk docs` exits with 0 when everything is OK" name="`cdk docs` exits with 0 when everything is OK" time="0">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:19" time="0.201" tests="1">
    <testcase classname=" applyDefaults() works" name=" applyDefaults() works" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="toolkit error" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:19" time="0.564" tests="5">
    <testcase classname="toolkit error isAssemblyError works" name="toolkit error isAssemblyError works" time="0">
    </testcase>
    <testcase classname="toolkit error isContextProviderError works" name="toolkit error isContextProviderError works" time="0.001">
    </testcase>
    <testcase classname="toolkit error types are correctly assigned" name="toolkit error types are correctly assigned" time="0">
    </testcase>
    <testcase classname="toolkit error isAuthenticationError works" name="toolkit error isAuthenticationError works" time="0">
    </testcase>
    <testcase classname="toolkit error isToolkitError works" name="toolkit error isToolkitError works" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:19" time="0.2" tests="1">
    <testcase classname=" converts buffer to information" name=" converts buffer to information" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="logging" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:19" time="0.929" tests="19">
    <testcase classname="logging CI mode behavior correctly switches between stdout and stderr based on CI mode" name="logging CI mode behavior correctly switches between stdout and stderr based on CI mode" time="0.001">
    </testcase>
    <testcase classname="logging stream selection error() always writes to stderr with both styles" name="logging stream selection error() always writes to stderr with both styles" time="0.001">
    </testcase>
    <testcase classname="logging stream selection info() writes to stdout in CI mode with both styles" name="logging stream selection info() writes to stdout in CI mode with both styles" time="0">
    </testcase>
    <testcase classname="logging stream selection info() writes to stderr by default with both styles" name="logging stream selection info() writes to stderr by default with both styles" time="0.001">
    </testcase>
    <testcase classname="logging stream selection result() always writes to stdout with both styles" name="logging stream selection result() always writes to stdout with both styles" time="0">
    </testcase>
    <testcase classname="logging edge cases handles null and undefined arguments with both styles" name="logging edge cases handles null and undefined arguments with both styles" time="0">
    </testcase>
    <testcase classname="logging edge cases handles circular references in objects with both styles" name="logging edge cases handles circular references in objects with both styles" time="0.001">
    </testcase>
    <testcase classname="logging styled output highlight handles complex objects with styling" name="logging styled output highlight handles complex objects with styling" time="0">
    </testcase>
    <testcase classname="logging styled output success() adds green color to output with both styles" name="logging styled output success() adds green color to output with both styles" time="0">
    </testcase>
    <testcase classname="logging styled output success handles format strings with styling" name="logging styled output success handles format strings with styling" time="0">
    </testcase>
    <testcase classname="logging styled output highlight() adds bold formatting to output with both styles" name="logging styled output highlight() adds bold formatting to output with both styles" time="0">
    </testcase>
    <testcase classname="logging formatted messages handles objects in format strings with both styles" name="logging formatted messages handles objects in format strings with both styles" time="0.001">
    </testcase>
    <testcase classname="logging formatted messages handles format strings correctly with both styles" name="logging formatted messages handles format strings correctly with both styles" time="0">
    </testcase>
    <testcase classname="logging formatted messages handles multiple style changes in single call" name="logging formatted messages handles multiple style changes in single call" time="0">
    </testcase>
    <testcase classname="logging log levels debug messages only show at debug level with both styles" name="logging log levels debug messages only show at debug level with both styles" time="0">
    </testcase>
    <testcase classname="logging log levels trace messages only show at trace level with both styles" name="logging log levels trace messages only show at trace level with both styles" time="0.001">
    </testcase>
    <testcase classname="logging log levels respects log level settings with both styles" name="logging log levels respects log level settings with both styles" time="0">
    </testcase>
    <testcase classname="logging message codes validates message codes correctly" name="logging message codes validates message codes correctly" time="0">
    </testcase>
    <testcase classname="logging message codes uses default codes when none provided" name="logging message codes uses default codes when none provided" time="0">
    </testcase>
  </testsuite>
  <testsuite name="`cdk doctor`" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:20" time="0.209" tests="1">
    <testcase classname="`cdk doctor` exits with 0 when everything is OK" name="`cdk doctor` exits with 0 when everything is OK" time="0.004">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:18" time="1.596" tests="5">
    <testcase classname=" don&apos;t throw exception - no key found but ignoreErrorOnMissingContext is true" name=" don&apos;t throw exception - no key found but ignoreErrorOnMissingContext is true" time="0.086">
    </testcase>
    <testcase classname=" looks up the requested Key - single result" name=" looks up the requested Key - single result" time="0.004">
    </testcase>
    <testcase classname=" looks up the requested Key - multiple results" name=" looks up the requested Key - multiple results" time="0.04">
    </testcase>
    <testcase classname=" throw exception - no key found" name=" throw exception - no key found" time="0.023">
    </testcase>
    <testcase classname=" looks up the requested Key - multiple results with pagination" name=" looks up the requested Key - multiple results with pagination" time="0.006">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:18" time="1.882" tests="10">
    <testcase classname=" empty template" name=" empty template" time="0.04">
    </testcase>
    <testcase classname=" add log groups from lambda function when using custom LoggingConfig using Ref" name=" add log groups from lambda function when using custom LoggingConfig using Ref" time="0.027">
    </testcase>
    <testcase classname=" log groups without physical names are added" name=" log groups without physical names are added" time="0.026">
    </testcase>
    <testcase classname=" add log groups from lambda function when using custom LoggingConfig" name=" add log groups from lambda function when using custom LoggingConfig" time="0.078">
    </testcase>
    <testcase classname=" add log groups from lambda function" name=" add log groups from lambda function" time="0.031">
    </testcase>
    <testcase classname=" excluded log groups are not added" name=" excluded log groups are not added" time="0.01">
    </testcase>
    <testcase classname=" add log groups from lambda function without physical name" name=" add log groups from lambda function without physical name" time="0.013">
    </testcase>
    <testcase classname=" add log groups from ECS Task Definitions" name=" add log groups from ECS Task Definitions" time="0.01">
    </testcase>
    <testcase classname=" add log groups from State Machines" name=" add log groups from State Machines" time="0.016">
    </testcase>
    <testcase classname=" unassociated log groups are added" name=" unassociated log groups are added" time="0.025">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:20" time="0.215" tests="10">
    <testcase classname=" formatting a failing SDK call looks broadly reasonable" name=" formatting a failing SDK call looks broadly reasonable" time="0.005">
    </testcase>
    <testcase classname=" formatting a failing SDK call includes attempts and retries if greater than 1" name=" formatting a failing SDK call includes attempts and retries if greater than 1" time="0.001">
    </testcase>
    <testcase classname=" formatting a failing SDK call includes the error" name=" formatting a failing SDK call includes the error" time="0.001">
    </testcase>
    <testcase classname=" formatting a successful SDK call looks broadly reasonable" name=" formatting a successful SDK call looks broadly reasonable" time="0">
    </testcase>
    <testcase classname=" formatting a successful SDK call includes attempts and retries if greater than 1" name=" formatting a successful SDK call includes attempts and retries if greater than 1" time="0.001">
    </testcase>
    <testcase classname="SdkToCliLogger trace method does not call notify" name="SdkToCliLogger trace method does not call notify" time="0.001">
    </testcase>
    <testcase classname="SdkToCliLogger warn method logs to notify" name="SdkToCliLogger warn method logs to notify" time="0.002">
    </testcase>
    <testcase classname="SdkToCliLogger error method logs to notify" name="SdkToCliLogger error method logs to notify" time="0.002">
    </testcase>
    <testcase classname="SdkToCliLogger info method logs to notify" name="SdkToCliLogger info method logs to notify" time="0.001">
    </testcase>
    <testcase classname="SdkToCliLogger debug method does not call notify" name="SdkToCliLogger debug method does not call notify" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="some" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:20" time="0.526" tests="5">
    <testcase classname="some childless tree" name="some childless tree" time="0">
    </testcase>
    <testcase classname="some tree does not match predicate" name="some tree does not match predicate" time="0.002">
    </testcase>
    <testcase classname="some tree matches predicate" name="some tree matches predicate" time="0">
    </testcase>
    <testcase classname="loadTreeFromDir cannot find tree" name="loadTreeFromDir cannot find tree" time="0">
    </testcase>
    <testcase classname="loadTreeFromDir can find tree" name="loadTreeFromDir can find tree" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:20" time="0.178" tests="5">
    <testcase classname=" validate emission of very long lines" name=" validate emission of very long lines" time="0.007">
    </testcase>
    <testcase classname=" quote the word &quot;ON&quot;" name=" quote the word &quot;ON&quot;" time="0.002">
    </testcase>
    <testcase classname=" quote number-like strings with a leading 0" name=" quote number-like strings with a leading 0" time="0">
    </testcase>
    <testcase classname=" validate that our YAML correctly emits quoted colons in a list" name=" validate that our YAML correctly emits quoted colons in a list" time="0.001">
    </testcase>
    <testcase classname=" do not quote octal numbers that arent really octal" name=" do not quote octal numbers that arent really octal" time="0">
    </testcase>
  </testsuite>
  <testsuite name="rangeFromSemver" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:20" time="0.153" tests="3">
    <testcase classname="rangeFromSemver pep valid" name="rangeFromSemver pep valid" time="0">
    </testcase>
    <testcase classname="rangeFromSemver invalid" name="rangeFromSemver invalid" time="0.015">
    </testcase>
    <testcase classname="rangeFromSemver bracket valid" name="rangeFromSemver bracket valid" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:20" time="0.779" tests="4">
    <testcase classname=" can set values in Context object if first is immutable" name=" can set values in Context object if first is immutable" time="0.001">
    </testcase>
    <testcase classname=" can delete values from Context object" name=" can delete values from Context object" time="0">
    </testcase>
    <testcase classname=" can clear all values in all objects" name=" can clear all values in all objects" time="0.001">
    </testcase>
    <testcase classname=" can set values in Context object" name=" can set values in Context object" time="0">
    </testcase>
  </testsuite>
  <testsuite name="Rewritable Block Tests" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:20" time="0.121" tests="5">
    <testcase classname="Rewritable Block Tests display accounts for newlines in output" name="Rewritable Block Tests display accounts for newlines in output" time="0.002">
    </testcase>
    <testcase classname="Rewritable Block Tests removeEmptyLines only removes trailing lines" name="Rewritable Block Tests removeEmptyLines only removes trailing lines" time="0.001">
    </testcase>
    <testcase classname="Rewritable Block Tests displayLines writes maximum lines based on rows if there are more lines than rows" name="Rewritable Block Tests displayLines writes maximum lines based on rows if there are more lines than rows" time="0.001">
    </testcase>
    <testcase classname="Rewritable Block Tests displayLines writes maximum lines based on lines length if rows is undefined" name="Rewritable Block Tests displayLines writes maximum lines based on lines length if rows is undefined" time="0">
    </testcase>
    <testcase classname="Rewritable Block Tests displayLines writes maximum lines based on lines length if there are less lines than rows" name="Rewritable Block Tests displayLines writes maximum lines based on lines length if there are less lines than rows" time="0">
    </testcase>
  </testsuite>
  <testsuite name="toYAML" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:20" time="0.472" tests="3">
    <testcase classname="toYAML does not wrap lines" name="toYAML does not wrap lines" time="0.001">
    </testcase>
    <testcase classname="obscureTemplate removes CheckBootstrapVersion rule only" name="obscureTemplate removes CheckBootstrapVersion rule only" time="0">
    </testcase>
    <testcase classname="obscureTemplate removes all rules when CheckBootstrapVersion is the only rule" name="obscureTemplate removes all rules when CheckBootstrapVersion is the only rule" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:20" time="0.573" tests="6">
    <testcase classname=" test parsing of falsey CI values: &quot;false&quot; parses as false" name=" test parsing of falsey CI values: &quot;false&quot; parses as false" time="0.002">
    </testcase>
    <testcase classname=" test parsing of falsey CI values: &quot;banana&quot; parses as true" name=" test parsing of falsey CI values: &quot;banana&quot; parses as true" time="0">
    </testcase>
    <testcase classname=" test parsing of falsey CI values: &quot;&quot; parses as true" name=" test parsing of falsey CI values: &quot;&quot; parses as true" time="0.003">
    </testcase>
    <testcase classname=" test parsing of falsey CI values: &quot;1&quot; parses as true" name=" test parsing of falsey CI values: &quot;1&quot; parses as true" time="0">
    </testcase>
    <testcase classname=" test parsing of falsey CI values: &quot;0&quot; parses as false" name=" test parsing of falsey CI values: &quot;0&quot; parses as false" time="0">
    </testcase>
    <testcase classname=" test parsing of falsey CI values: &quot;true&quot; parses as true" name=" test parsing of falsey CI values: &quot;true&quot; parses as true" time="0">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:20" time="0.607" tests="3">
    <testcase classname=" banner works for formatted msgs" name=" banner works for formatted msgs" time="0.002">
    </testcase>
    <testcase classname=" no banner on empty msg list" name=" no banner on empty msg list" time="0">
    </testcase>
    <testcase classname=" banner works as expected" name=" banner works as expected" time="0">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:18" time="2.089" tests="2">
    <testcase classname=" calls DescribeImages on the request" name=" calls DescribeImages on the request" time="0.007">
    </testcase>
    <testcase classname=" returns the most recent AMI matching the criteria" name=" returns the most recent AMI matching the criteria" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:21" time="0.165" tests="3">
    <testcase classname=" partition splits the collection in twain" name=" partition splits the collection in twain" time="0.001">
    </testcase>
    <testcase classname=" flatten combines arrays" name=" flatten combines arrays" time="0">
    </testcase>
    <testcase classname=" flatMap maps and combines" name=" flatMap maps and combines" time="0">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:20" time="0.565" tests="8">
    <testcase classname=" provider returning expiring credentials must keep returning the same object type" name=" provider returning expiring credentials must keep returning the same object type" time="0.006">
    </testcase>
    <testcase classname=" token expiration is allowed to be null" name=" token expiration is allowed to be null" time="0">
    </testcase>
    <testcase classname=" plugin can return V3 compatible credentials that expire" name=" plugin can return V3 compatible credentials that expire" time="0.001">
    </testcase>
    <testcase classname=" plugin can return V2 compatible credential-provider with initially empty keys" name=" plugin can return V2 compatible credential-provider with initially empty keys" time="0.001">
    </testcase>
    <testcase classname=" plugin can return V2 compatible credential-provider" name=" plugin can return V2 compatible credential-provider" time="0">
    </testcase>
    <testcase classname=" plugin can return V3 compatible credential-provider" name=" plugin can return V3 compatible credential-provider" time="0">
    </testcase>
    <testcase classname=" plugin can return V3 compatible credentials" name=" plugin can return V3 compatible credentials" time="0.001">
    </testcase>
    <testcase classname=" plugin must not return something that is not a credential" name=" plugin must not return something that is not a credential" time="0.004">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:41:21" time="0.462" tests="5">
    <testcase classname=" plugin that registers an invalid Context Provider throws" name=" plugin that registers an invalid Context Provider throws" time="0.005">
    </testcase>
    <testcase classname=" load a plugin using the PluginHost" name=" load a plugin using the PluginHost" time="0">
    </testcase>
    <testcase classname=" fail to load a plugin using the PluginHost" name=" fail to load a plugin using the PluginHost" time="0.001">
    </testcase>
    <testcase classname=" plugin that registers a Context Provider" name=" plugin that registers a Context Provider" time="0">
    </testcase>
    <testcase classname=" plugin that registers a Credential Provider" name=" plugin that registers a Credential Provider" time="0">
    </testcase>
  </testsuite>
  <testsuite name="Migrate Function Tests" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:40:45" time="51.505" tests="32">
    <testcase classname="Migrate Function Tests generateCdkApp generates the expected cdk app when called for python" name="Migrate Function Tests generateCdkApp generates the expected cdk app when called for python" time="4.269">
    </testcase>
    <testcase classname="Migrate Function Tests generateCdkApp generates the expected cdk app when called for csharp" name="Migrate Function Tests generateCdkApp generates the expected cdk app when called for csharp" time="0.647">
    </testcase>
    <testcase classname="Migrate Function Tests parseSourceOptions does not throw when only --from-path is supplied" name="Migrate Function Tests parseSourceOptions does not throw when only --from-path is supplied" time="0.002">
    </testcase>
    <testcase classname="Migrate Function Tests parseSourceOptions does now throw when only --from-stack is provided" name="Migrate Function Tests parseSourceOptions does now throw when only --from-stack is provided" time="0">
    </testcase>
    <testcase classname="Migrate Function Tests generateStack throws error when called for other language" name="Migrate Function Tests generateStack throws error when called for other language" time="0.031">
    </testcase>
    <testcase classname="Migrate Function Tests readFromPath throws error when template file is empty" name="Migrate Function Tests readFromPath throws error when template file is empty" time="0">
    </testcase>
    <testcase classname="Migrate Function Tests generateStack generates the expected stack string when called for python" name="Migrate Function Tests generateStack generates the expected stack string when called for python" time="0.001">
    </testcase>
    <testcase classname="Migrate Function Tests generateStack generates the expected stack string when called for typescript" name="Migrate Function Tests generateStack generates the expected stack string when called for typescript" time="0.002">
    </testcase>
    <testcase classname="Migrate Function Tests setEnvironment sets account and region when provided" name="Migrate Function Tests setEnvironment sets account and region when provided" time="0">
    </testcase>
    <testcase classname="Migrate Function Tests generatedCdkApp generates a zip file when --compress is used" name="Migrate Function Tests generatedCdkApp generates a zip file when --compress is used" time="0.097">
    </testcase>
    <testcase classname="Migrate Function Tests readFromPath throws error when template file does not exist at a given path" name="Migrate Function Tests readFromPath throws error when template file does not exist at a given path" time="0.001">
    </testcase>
    <testcase classname="Migrate Function Tests generatedCdkApp generates the expected cdk app when called for go" name="Migrate Function Tests generatedCdkApp generates the expected cdk app when called for go" time="0.172">
    </testcase>
    <testcase classname="Migrate Function Tests generateCdkApp generates the expected cdk app when called for typescript" name="Migrate Function Tests generateCdkApp generates the expected cdk app when called for typescript" time="21.601">
    </testcase>
    <testcase classname="Migrate Function Tests serEnvironment uses default account and region when not provided" name="Migrate Function Tests serEnvironment uses default account and region when not provided" time="0">
    </testcase>
    <testcase classname="Migrate Function Tests readFromStack throws error when stack exists but the status is not healthy" name="Migrate Function Tests readFromStack throws error when stack exists but the status is not healthy" time="0.009">
    </testcase>
    <testcase classname="Migrate Function Tests readFromPath produces a string representation of the template at a given path" name="Migrate Function Tests readFromPath produces a string representation of the template at a given path" time="0.001">
    </testcase>
    <testcase classname="Migrate Function Tests readFromStack throws error when no stack exists with the stack name in the account and region" name="Migrate Function Tests readFromStack throws error when no stack exists with the stack name in the account and region" time="0.003">
    </testcase>
    <testcase classname="Migrate Function Tests parseSourceOptions throws if both --from-path and --from-stack is provided" name="Migrate Function Tests parseSourceOptions throws if both --from-path and --from-stack is provided" time="0">
    </testcase>
    <testcase classname="Migrate Function Tests generateStack generates the expected stack string when called for go" name="Migrate Function Tests generateStack generates the expected stack string when called for go" time="0.002">
    </testcase>
    <testcase classname="Migrate Function Tests generateStack throws error for invalid resource property" name="Migrate Function Tests generateStack throws error for invalid resource property" time="0.002">
    </testcase>
    <testcase classname="Migrate Function Tests readFromStack produces a string representation of the template retrieved from CloudFormation" name="Migrate Function Tests readFromStack produces a string representation of the template retrieved from CloudFormation" time="0.009">
    </testcase>
    <testcase classname="Migrate Function Tests generateCdkApp generates the expected cdk app when called for java" name="Migrate Function Tests generateCdkApp generates the expected cdk app when called for java" time="11.459">
    </testcase>
    <testcase classname="Migrate Function Tests generateStack generates the expected stack string when called for csharp" name="Migrate Function Tests generateStack generates the expected stack string when called for csharp" time="0.001">
    </testcase>
    <testcase classname="Migrate Function Tests generateStack generates the expected stack string when called for java" name="Migrate Function Tests generateStack generates the expected stack string when called for java" time="0.001">
    </testcase>
    <testcase classname="Migrate Function Tests parseSourceOptions returns from-scan when neither --from-path or --from-stack are provided" name="Migrate Function Tests parseSourceOptions returns from-scan when neither --from-path or --from-stack are provided" time="0">
    </testcase>
    <testcase classname="Migrate Function Tests generateCdkApp adds cdk-migrate key in context" name="Migrate Function Tests generateCdkApp adds cdk-migrate key in context" time="10.654">
    </testcase>
    <testcase classname="generateTemplate generateTemplate throws an error when an invalid key is passed in the filters" name="generateTemplate generateTemplate throws an error when an invalid key is passed in the filters" time="0.01">
    </testcase>
    <testcase classname="generateTemplate generateTemplate successfully defaults to latest scan instead of starting a new one" name="generateTemplate generateTemplate successfully defaults to latest scan instead of starting a new one" time="0.012">
    </testcase>
    <testcase classname="generateTemplate generateTemplate throws an error when from-scan most-recent is passed but no scans are found." name="generateTemplate generateTemplate throws an error when from-scan most-recent is passed but no scans are found." time="0.006">
    </testcase>
    <testcase classname="generateTemplate generateTemplate defaults to starting a new scan when no options are provided and no scans are found" name="generateTemplate generateTemplate defaults to starting a new scan when no options are provided and no scans are found" time="0.009">
    </testcase>
    <testcase classname="generateTemplate generateTemplate successfully generates template with a new scan" name="generateTemplate generateTemplate successfully generates template with a new scan" time="0.008">
    </testcase>
    <testcase classname="generateTemplate generateTemplate successfully generates templates with valid filter options" name="generateTemplate generateTemplate successfully generates templates with valid filter options" time="0.009">
    </testcase>
  </testsuite>
  <testsuite name="expandPlaceholders" errors="0" failures="0" skipped="0" timestamp="2025-02-18T18:40:45" time="55.225" tests="20">
    <testcase classname="expandPlaceholders distinguish library and CLI version" name="expandPlaceholders distinguish library and CLI version" time="0.008">
    </testcase>
    <testcase classname="constructs version --generate-only should skip git init" name="constructs version --generate-only should skip git init" time="0.041">
    </testcase>
    <testcase classname="constructs version CLI uses recommended feature flags from data file to initialize context" name="constructs version CLI uses recommended feature flags from data file to initialize context" time="0.08">
    </testcase>
    <testcase classname="constructs version create a TypeScript library project" name="constructs version create a TypeScript library project" time="25.873">
    </testcase>
    <testcase classname="constructs version create a Java app project" name="constructs version create a Java app project" time="0.115">
    </testcase>
    <testcase classname="constructs version create a .NET app project in csharp" name="constructs version create a .NET app project in csharp" time="2.122">
    </testcase>
    <testcase classname="constructs version create a .NET app project in fsharp" name="constructs version create a .NET app project in fsharp" time="1.573">
    </testcase>
    <testcase classname="constructs version asking for a nonexistent template fails" name="constructs version asking for a nonexistent template fails" time="0.045">
    </testcase>
    <testcase classname="constructs version csharp app with spaces" name="constructs version csharp app with spaces" time="1.644">
    </testcase>
    <testcase classname="constructs version verify &quot;future flags&quot; are added to cdk.json" name="constructs version verify &quot;future flags&quot; are added to cdk.json" time="4.383">
    </testcase>
    <testcase classname="constructs version create a Python app project" name="constructs version create a Python app project" time="0.027">
    </testcase>
    <testcase classname="constructs version create a TypeScript app project" name="constructs version create a TypeScript app project" time="9.329">
    </testcase>
    <testcase classname="constructs version fsharp app with spaces" name="constructs version fsharp app with spaces" time="0.59">
    </testcase>
    <testcase classname="constructs version CLI uses init versions file to initialize template" name="constructs version CLI uses init versions file to initialize template" time="0.035">
    </testcase>
    <testcase classname="constructs version git directory does not throw off the initer!" name="constructs version git directory does not throw off the initer!" time="0.025">
    </testcase>
    <testcase classname="constructs version create a JavaScript app project" name="constructs version create a JavaScript app project" time="8.624">
    </testcase>
    <testcase classname="constructs version asking for a template but no language prints and throws" name="constructs version asking for a template but no language prints and throws" time="0.002">
    </testcase>
    <testcase classname=" when no version number is present (e.g., local development), the v2 templates are chosen by default" name=" when no version number is present (e.g., local development), the v2 templates are chosen by default" time="0.001">
    </testcase>
    <testcase classname=" exercise printing available templates" name=" exercise printing available templates" time="0.001">
    </testcase>
    <testcase classname=" check available init languages" name=" check available init languages" time="0.001">
    </testcase>
  </testsuite>
</testsuites>